#
# Copyright (c) 1997 Enterprise Systems Management Corp.
#
# This file is part of UName*It.
#
# UName*It is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later
# version.
#
# UName*It is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with UName*It; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
#
# $Id: udbproc.tcl,v 1.6.58.7 1997/10/11 00:55:17 viktor Exp $
#

#
# Source various files from library directory.  Make into packages
# or move bodily into this file as the opportunity arises
#
source ../library/atomic.tcl
source ../library/dump_db.tcl
source ../library/restore_db.tcl
source ../library/unameit_server.tcl

#
#-----------------------------------------------------------------------------
# INET: Routines for management of network hierarchies:
# Validation, autogeneration,  and commit time integrity checks.
#-----------------------------------------------------------------------------
#

#
# Network autogeneration proc,  called from network validation trigger
# if the start address of a network is not specified or implied.
#
# Will generate subnets even for parent networks that are not obviously
# subnetted.  The parent network status may change by commit time.
#
proc unameit_inet_auto_net {fname uuid nVar sVar eVar bVar mVar tVar} {
    #
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    set fbits [expr {8 * [set foctets $inet_info($fname.octets)]}]
    #
    foreach param {net_netof net_start net_end net_bits net_mask net_type} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    upvar 1\
	$nVar net_netof\
	$sVar net_start\
	$eVar net_end\
	$bVar net_bits\
	$mVar net_mask\
	$tVar net_type
    #
    udb_fetch $net_netof\
	$anames(net_start)\
	$anames(net_end)\
	$anames(net_bits)\
	$anames(net_mask)\
	$anames(net_type)
    #
    upvar 0 $net_netof netItem
    set pstart $netItem($anames(net_start))
    set pend $netItem($anames(net_end))
    set pmask $netItem($anames(net_mask))
    set pbits $netItem($anames(net_bits))
    set ptype $netItem($anames(net_type))
    set pmbits [unameit_address_mask_bits $pmask]
    #
    # Cannot autogenerate toplevel nets.
    #
    if {$pbits == 0} {
	#
	# Top level nets may not be autogenerated.
	#
	unameit_error EINETAUTOTOP $uuid
    }
    #
    set mbits [unameit_address_mask_bits $net_mask]
    #
    if {[cequal $net_bits ""]} {
	if {$pmbits == $pbits} {
	    if {$mbits <= $pmbits} {
		unameit_error ENULL $uuid $anames(net_bits)
	    }
	    set net_bits $mbits
	} else {
	    set net_bits $pmbits
	}
    }

    #
    # If no mask given,  compute a suitable mask.
    #
    if {[cequal $net_mask ""]} {
	if {$net_bits <= $pmbits} {
	    set mbits $pmbits
	} else {
	    set mbits $net_bits
	}
	set net_mask [unameit_address_make_mask $foctets $mbits]
    }

    #
    # Autogenerate a subnet, with the given or computed prefix bit count.
    #
    lassign [udb_inet_auto_net $fname $net_netof $net_bits $uuid] start bits

    #
    # Check for subnet zero.
    #
    if {[cequal Reserved $inet_info($fname.net_zero)] &&
	    [cequal $pstart $start]} {
	#
	# Try to use second half of zeroth subnet if the latter is big enough.
	#
	set m [unameit_address_make_mask $foctets [expr {$bits - $fbits}]]
	set start [unameit_address_or $start $m]
	if {[incr bits] > $net_bits} {
	    unameit_error EINETFULL $uuid $anames(net_netof) $net_netof
	}
    }

    set m [unameit_address_make_mask $foctets [expr {$bits - $fbits}]]
    set net_start [unameit_address_mask $start $m]

    set m [unameit_address_make_mask $foctets [expr {$net_bits - $fbits}]]
    set net_end [unameit_address_or $net_start $m]

    #
    # Check for last subnet.
    #
    if {[cequal Reserved $inet_info($fname.last_net)] &&
	    [cequal $net_end $pend]} {
	unameit_error EINETFULL $uuid $anames(net_netof) $net_netof
    }
}

#
# Network validation trigger,  runs before create and update.
# Computes missing fields and checks for internal consistency.
# Tweaks addresses to lie in (new) parent network on update of network only.
#
# Global consistency (w.r.t to parent net and subnodes) is deferred to
# commit time.
#
proc unameit_inet_network_trigger {class uuid event newarr fname args} {
    #
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    set fbits [expr {8 * [set foctets $inet_info($fname.octets)]}]
    #
    foreach param {net_netof net_start net_end net_bits net_mask net_type} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    upvar 1 $uuid $uuid $uuid old $newarr new
    #
    # Bind local variables to new values
    #
    foreach var {net_netof net_start net_end net_bits net_mask net_type} {
	upvar 0 new($anames($var)) $var
    }
    #
    # On update compute consequential changes
    #
    switch -- $event update {
	foreach var {net_netof net_start net_end net_bits net_mask net_type} {
	    #
	    # Does new value exist, and if so is it empty?
	    #
	    upvar 0 new($anames($var)) val
	    #
	    if {[info exists val]} {
		if {![cequal $val ""]} {
		    # New value
		    set state($var) n
		} else {
		    # Cleared value
		    set state($var) c
		}
	    } else {
		# Old value
		set state($var) o
		set val $old($anames($var))
	    }
	}
	set k\
	  $state(net_netof).$state(net_start).$state(net_end).$state(net_bits)
	switch -- $k {
	    n.o.o.o {
		#
		# New net,  adjust start and end as little as possible
		# to lie inside new network
		#
		udb_fetch $net_netof $anames(net_start) $anames(net_bits)
		upvar 0 $net_netof netItem
		set pm [unameit_address_make_mask\
			$foctets $netItem($anames(net_bits))]
		set net_start\
		    [unameit_address_or $netItem($anames(net_start))\
			[unameit_address_mask $net_start $pm]]
		set net_end\
		    [unameit_address_or $netItem($anames(net_start))\
			[unameit_address_mask $net_end $pm]]
		#
		# Clear net, to allow reparenting under an ancestor
		# network of resulting net for new start/end pair.
		#
		set net_netof ""
	    }
	    o.n.o.o - o.o.o.n - o.n.o.n {
		#
		# New start address or bit count or both
		# recompute end and net
		#
		set net_end [set net_netof ""]
	    }
	    o.n.n.o - o.o.n.o {
		#
		# New end, new or same start:
		# recompute bits and net.
		#
		set net_bits [set net_netof ""]
	    }
	}
	if {[cequal $state(net_mask) o]} {
	    #
	    # Adjust mask to follow bits if previously equal.
	    #
	    set mbits [unameit_address_mask_bits $net_mask]
	    if {$mbits == $old($anames(net_bits))} {
		set net_mask ""
	    }
	}
    }

    #
    # Make sure mask has contiguous bits (or is empty string).
    #
    set mbits [unameit_address_mask_bits $net_mask]
    if {$mbits < 0} {
	unameit_error EINETMASK $uuid $anames(net_mask) $net_mask
    }

    set k [llength $net_start].[llength $net_end].[llength $net_bits]
    switch -- $k {
	1.1.1 - 1.0.1 {
	    #
	    # Start and bits set, compute end
	    #
	    set m [unameit_address_make_mask\
		    $foctets [expr {$net_bits - $fbits}]]
	    set net_end [unameit_address_or $net_start $m]
	    #
	    # Make sure start and bits are compatible
	    #
	    if {$net_bits !=\
		    [unameit_address_common_bits $net_start $net_end]} {
		unameit_error EINETBITS $uuid\
		    $anames(net_bits) $net_bits\
		    $anames(net_start) $net_start
	    }
	}
	1.1.0 {
	    # start and end set compute bits
	    set net_bits [unameit_address_common_bits $net_start $net_end]
	    if {$net_bits < 0} {
		unameit_error EINETBOUNDS $uuid\
		    $anames(net_start) $net_start\
		    $anames(net_end) $net_end
	    }
	}
	0.1.1 {
	    #
	    # End and bits set, compute start
	    #
	    set m [unameit_address_make_mask\
		    $foctets [expr {$net_bits - $fbits}]]
	    set net_start [unameit_address_mask $net_end $m]
	    #
	    # Make sure end and bits are compatible
	    #
	    if {$net_bits !=\
		    [unameit_address_common_bits $net_start $net_end]} {
		unameit_error EINETBITS $uuid\
		    $anames(net_bits) $net_bits\
		    $anames(net_end) $net_end
	    }
	}
	default {
	    if {[cequal "" $net_netof]} {
		#
		# Not enough info
		#
		if {[cequal "" $net_start]} {
		    unameit_error ENULL $uuid $anames(net_start)
		} else {
		    unameit_error ENULL $uuid $anames(net_bits)
		}
	    }
	    set auto 1
	}
    }

    if {[info exists auto]} {
	unameit_inet_auto_net $fname $uuid\
	    net_netof net_start net_end net_bits net_mask net_type
	set mbits [unameit_address_mask_bits $net_mask]
    } else {

	## Compute the net (must match if specified)
	set netof [udb_inet_netof_net $fname $uuid $net_start $net_bits]

	if {[cequal "" $net_netof]} {
	    set net_netof $netof
	} else {
	    #
	    # Make sure specified parent is "compatible" with computed prefix.
	    # We do not insist on a precise match.
	    #
	    udb_fetch $netof $anames(net_start)
	    upvar 0 ${netof}($anames(net_start)) netof_start
	    #
	    udb_fetch $net_netof $anames(net_start) $anames(net_bits)
	    upvar 0 ${net_netof}($anames(net_start)) net_netof_start
	    upvar 0 ${net_netof}($anames(net_bits)) net_netof_bits

	    set pm [unameit_address_make_mask $foctets $net_netof_bits]
	    set netof_prefix [unameit_address_and $netof_start $pm]

	    if {![cequal $net_netof_start $netof_prefix]} {
		unameit_error EINETPARENT $uuid $anames(net_netof) $net_netof
	    }
	    set net_netof $netof
	}

	#
	# Whoever creates the universe net,  should make sure it has
	# Zero mask and "Variable" Type.  The universe comes preloaded
	# So we do not bother validating it that much.
	#
	if {[cequal $net_netof ""]} return

	#
	# Fill in default mask if none given.
	#
	if {[cequal $net_mask ""]} {
	    set net_mask\
		[unameit_address_make_mask $foctets [set mbits $net_bits]]
	}
    }

    #
    # Check boundary cases.
    #
    if {$mbits == $net_bits && [cequal Fixed $net_type]} {
	#
	# Unsubnetted network
	#
	set k $inet_info($fname.node_zero).$inet_info($fname.last_node)
	switch -- $k {
	    Available.Available {
		set maxbits [expr {$fbits - 1}]
	    }
	    default {
		set maxbits [expr {$fbits - 2}]
	    }
	}
	#
	# Make sure prefix leaves enough room for nodes
	#
	if {$net_bits > $maxbits} {
	    unameit_error EINETNONODES\
		$uuid $anames(net_bits) $net_bits
	}
    } else {
	#
	# Subnetted network
	#
	set k $inet_info($fname.net_zero).$inet_info($fname.last_net)
	switch -- $k {
	    Available.Available {
		set maxbits [expr {$fbits - 2}]
		set minmbits [expr {$net_bits + 1}]
	    }
	    default {
		set maxbits [expr {$fbits - 4}]
		set minmbits [expr {$net_bits + 2}]
	    }
	}
	#
	# Make sure mask is not too tight for subnets if not == net_bits.
	#
	if {$mbits != $net_bits && $mbits < $minmbits} {
	    unameit_error EINETMASK $uuid $anames(net_mask) $net_mask
	}
	#
	# Make sure prefix and mask both leave enough room for subnets
	# Since we just checked that the mask has at least as many bits as
	# the prefix,  we bound the prefix if we bound the mask!
	#
	if {$mbits > $maxbits} {
	    unameit_error EINETMASK $uuid $anames(net_mask) $net_mask
	}
    }

    #
    # On update clear unchanged values.
    #
    if {[cequal $event update]} {
	foreach var {net_netof net_start net_end net_bits net_mask net_type} {
	    upvar 0 $var val
	    if {[cequal $val $old($anames($var))]} {
		unset val
	    }
	}
    }
}

#
# Node validation trigger.  Checks consistency of network w.r.t address.
# Tweaks addresses to lie in (new) parent network on update of network only.
# Computes network if not specified,  calls autogeneration of address
# if not specified.  If both address and parent network are blank,  the
# node will have no address or network.
#
proc unameit_inet_node_trigger {class uuid event newarr fname args} {
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    set fbits [expr {8 * [set foctets $inet_info($fname.octets)]}]
    #
    foreach param {node_netof node_address net_start net_bits} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    upvar 1 $uuid $uuid $uuid old $newarr new
    #
    # Bind local variables to new values
    #
    foreach var {node_netof node_address} {
	upvar 0 new($anames($var)) $var
    }
    #
    # On update compute consequential changes
    #
    switch -- $event update {
	foreach var {node_netof node_address} {
	    #
	    # Does new value exist, and if so is it empty?
	    #
	    upvar 0 new($anames($var)) val
	    #
	    if {[info exists val]} {
		if {![cequal $val ""]} {
		    # New value
		    set state($var) n
		} else {
		    # Cleared value
		    set state($var) c
		}
	    } else {
		# Old value
		set state($var) o
		set val $old($anames($var))
	    }
	}
	set k $state(node_netof).$state(node_address)
	switch -- $k {
	    n.o {
		#
		# New network,  adjust address as little as possible
		# to lie inside new network
		#
		udb_fetch $node_netof $anames(net_start) $anames(net_bits)
		upvar 0 $node_netof netItem
		set pm [unameit_address_make_mask\
			$foctets $netItem($anames(net_bits))]
		set node_address\
		    [unameit_address_or $netItem($anames(net_start))\
			[unameit_address_mask $node_address $pm]]
		#
		# Clear network to allow reparenting under an ancestor
		# network of resulting network for new address.
		#
		set node_netof ""
	    }
	    o.n {
		#
		# New address clear network
		#
		set node_netof ""
	    }
	}
    }

    set k [llength $node_netof].[llength $node_address]
    switch -- $k {
	1.1 {
	    #
	    # Both set, check for compatibility
	    #
	    set netof [udb_inet_netof_node $fname $uuid $node_address]
	    if {![cequal $netof $node_netof]} {
		#
		# Make sure specified parent is "compatible" with
		# computed prefix. We do not insist on a precise match.
		#
		udb_fetch $netof $anames(net_start)
		upvar 0 ${netof}($anames(net_start)) netof_start
		#
		udb_fetch $node_netof $anames(net_start) $anames(net_bits)
		upvar 0 ${node_netof}($anames(net_start)) node_netof_start
		upvar 0 ${node_netof}($anames(net_bits)) node_netof_bits

		set pm [unameit_address_make_mask $foctets $node_netof_bits]
		set netof_prefix [unameit_address_and $netof_start $pm]

		if {![cequal $node_netof_start $netof_prefix]} {
		    unameit_error EINETPARENT\
			$uuid $anames(node_netof) $node_netof
		}
	    }
	}
	1.0 {
	    #
	    # Net set, autogenerate address
	    #
	    unameit_inet_auto_node $fname $class $uuid node_netof node_address
	    return
	}
	0.1 {
	    #
	    # Address only set compute network
	    #
	    set node_netof [udb_inet_netof_node $fname $uuid $node_address]
	}
	0.0 {
	    #
	    # Both cleared,  no address.
	    #
	    return
	}
    }

    #
    # On update clear unchanged values.
    #
    if {[cequal $event update]} {
	foreach var {node_netof node_address} {
	    upvar 0 $var val
	    if {[cequal $val $old($anames($var))]} {
		unset val
	    }
	}
    }
}

#
# Host validation trigger.  Runs node validation,  but rejects NULL addresses.
#
proc unameit_ipv4_host_trigger {class uuid event newarr args} {
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    foreach param {node_netof node_address} {
	set anames($param) $inet_info(ipv4.$param)
    }
    #
    upvar 1 $uuid $uuid $uuid old $newarr new
    #
    unameit_inet_node_trigger $class $uuid $event new ipv4
    #
    if {![info exists new($anames(node_address))]} {
	return
    }
    #
    # Disallow empty address
    #
    if {[cequal "" $new($anames(node_address))]} {
	unameit_error ENULL $uuid $anames(node_address)
    }
}

#
# Range validation trigger.  Range start/end addresses are mandatory.
# Computes parent net if not specified.  Tweaks addresses to lie in
# (new) parent network on update of network only.
#
proc unameit_inet_range_trigger {class uuid event newarr fname args} {
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    set fbits [expr {8 * [set foctets $inet_info($fname.octets)]}]
    #
    foreach param {range_netof range_start range_end net_start net_bits} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    upvar 1 $uuid $uuid $uuid old $newarr new
    #
    # Bind local variables to new values
    #
    foreach var {range_netof range_start range_end} {
	upvar 0 new($anames($var)) $var
    }
    #
    # On update compute consequential changes
    #
    switch -- $event update {
	foreach var {range_netof range_start range_end} {
	    #
	    # Does new value exist, and if so is it empty?
	    #
	    upvar 0 new($anames($var)) val
	    #
	    if {[info exists val]} {
		if {![cequal $val ""]} {
		    # New value
		    set state($var) n
		} else {
		    # Cleared value
		    set state($var) c
		}
	    } else {
		# Old value
		set state($var) o
		set val $old($anames($var))
	    }
	}
	set k $state(range_netof).$state(range_start).$state(range_end)
	switch -- $k {
	    n.o.o {
		#
		# New network,  adjust start and end as little as possible
		# to lie inside new network
		#
		udb_fetch $range_netof $anames(net_start) $anames(net_bits)
		upvar 0 $range_netof netItem
		set pm [unameit_address_make_mask\
			$foctets $netItem($anames(net_bits))]
		set range_start\
		    [unameit_address_or $netItem($anames(net_start))\
			[unameit_address_mask $range_start $pm]]
		set range_end\
		    [unameit_address_or $netItem($anames(net_start))\
			[unameit_address_mask $range_end $pm]]
		#
		# Clear and recompute network
		#
		set range_netof ""
	    }
	    o.n.o - o.n.n - o.o.n {
		#
		# New interval clear network
		#
		set range_netof ""
	    }
	}
    }

    #
    # Range start and end are mandatory.
    #
    if {[cequal "" $range_start]} {
	unameit_error ENULL $uuid $anames(range_start)
    }
    if {[cequal "" $range_end]} {
	unameit_error ENULL $uuid $anames(range_end)
    }

    #
    # inet_netof_range will also sanity check start/end
    #
    if {![cequal "" $range_netof]} {
	#
	# Both set, check for compatibility
	#
	set netof [udb_inet_netof_range $fname $uuid $range_start $range_end]
	if {![cequal $netof $range_netof]} {
	    #
	    # Make sure specified parent is "compatible" with
	    # computed prefix. We do not insist on a precise match.
	    #
	    udb_fetch $netof $anames(net_start)
	    upvar 0 ${netof}($anames(net_start)) netof_start
	    #
	    udb_fetch $range_netof $anames(net_start) $anames(net_bits)
	    upvar 0 ${range_netof}($anames(net_start)) range_netof_start
	    upvar 0 ${range_netof}($anames(net_bits)) range_netof_bits

	    set pm [unameit_address_make_mask $foctets $range_netof_bits]
	    set netof_prefix [unameit_address_and $netof_start $pm]

	    if {![cequal $range_netof_start $netof_prefix]} {
		unameit_error EINETPARENT\
		    $uuid $anames(range_netof) $range_netof
	    }
	}
    } else {
	#
	# Net not set compute it
	#
	set range_netof\
	    [udb_inet_netof_range $fname $uuid $range_start $range_end]
    }

    #
    # On update clear unchanged values.
    #
    if {[cequal $event update]} {
	foreach var {range_netof range_start range_end} {
	    upvar 0 $var val
	    if {[cequal $val $old($anames($var))]} {
		unset val
	    }
	}
    }
}

proc unameit_inet_check_nets {fname nets} {
    #
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    foreach param {\
	    node_netof\
	    range_netof\
	    net_netof net_start net_bits net_end net_mask net_type
	} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    # Any new nodes or ranges in the network are checked in the
    # node/range section.  So,  we need only check for parent net
    # compatibility and subnode type.
    #
    foreach net $nets {
	#
	# Get net info for each object,  hash parent networks
	# for checking.
	#
	upvar 0 ${net}($anames(net_netof)) net_netof
	#
	udb_fetch $net\
	    $anames(net_netof)\
	    $anames(net_start)\
	    $anames(net_bits)\
	    $anames(net_end)\
	    $anames(net_mask)\
	    $anames(net_type)
	#
	lappend checkNet($net_netof) $net
    }
    #
    # Check each parent network,  it must be subnetted
    #
    foreach net [array names checkNet] {
	#
	set cmd [list udb_fetch $net]
	foreach param {\
		net_start net_bits net_end net_mask net_type
	    } {
	    lappend cmd $anames($param)
	    upvar 0 ${net}($anames($param)) $param
	}
	eval $cmd
	#
	# Make sure net is subnetted
	#
	set mbits [unameit_address_mask_bits $net_mask]
	if {[cequal Fixed $net_type] && $mbits == $net_bits} {
	    unameit_error EINETNOTSUBNETTED\
		[lindex $checkNet($net) 0] $anames(net_netof) $net
	}
	#
	foreach subnet $checkNet($net) {
	    upvar 0\
		${subnet}($anames(net_start)) subnet_start\
		${subnet}($anames(net_bits)) subnet_bits\
		${subnet}($anames(net_end)) subnet_end
	    #
	    switch -- $net_type Fixed {
		if {![cequal $subnet_bits $mbits]} {
		    unameit_error EINETFIXEDBITS $subnet\
			$anames(net_bits) $subnet_bits\
			$anames(net_netof) $net
		}
	    }
	    #
	    switch -- $inet_info($fname.net_zero) Reserved {
		#
		# This also catches networks with a prefix just 1 bit bigger.
		#
		if {[cequal $subnet_start $net_start]} {
		    unameit_error EINETNETZERO $subnet\
			$anames(net_start) $subnet_start\
			$anames(net_netof) $net
		}
	    }
	    #
	    switch -- $inet_info($fname.last_net) Reserved {
		#
		# This also catches networks with a prefix just 1 bit bigger.
		#
		if {[cequal $subnet_end $net_end]} {
		    unameit_error EINETLASTNET $subnet\
			$anames(net_end) $subnet_end\
			$anames(net_netof) $net
		}
	    }
	}
    }
    #
    foreach net $nets {
	#
	# For nets mask or type changed but start/bits are unchanged,
	# we need to check subnode type.  Sadly we don't know which nets
	# are changed only this way,  so we just check them all.
	#
	upvar 0\
	    ${net}($anames(net_end)) net_bits\
	    ${net}($anames(net_type)) net_type\
	    ${net}($anames(net_mask)) net_mask
	#
	if {[cequal Fixed $net_type] &&
		[unameit_address_mask_bits $net_mask] == $net_bits} {
	    #
	    # Should not have subnets
	    #
	    set s [udb_inet_asubnet $net]
	    if {![cequal "" $s]} {
		unameit_error EINETNOTSUBNETTED $s $anames(net_netof) $net
	    }
	} else {
	    #
	    # Should not have ranges or nodes.
	    #
	    set r [lindex [udb_inet_net_ranges $fname $net] 0]
	    if {![cequal "" $r]} {
		unameit_error EINETSUBNETTED $r $anames(range_netof) $net
	    }
	    set n [udb_inet_net_anode $fname $net]
	    if {![cequal "" $n]} {
		unameit_error EINETSUBNETTED $n $anames(node_netof) $net
	    }
	}
    }
}

proc unameit_inet_check_ranges {fname ranges} {
    #
    upvar #0\
	UNAMEIT_INET_INFO inet_info
    #
    foreach param {\
	    node_address\
	    net_start net_end net_bits net_mask net_type\
	    range_netof range_start range_end range_type range_devices\
	} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    foreach range $ranges {
	#
	# Get range info for each object,  hash parent networks
	# for checking.
	#
	upvar 0 ${range}($anames(range_netof)) range_netof
	#
	udb_fetch $range\
	    $anames(range_netof)\
	    $anames(range_start)\
	    $anames(range_end)\
	    $anames(range_type)\
	    $anames(range_devices)
	#
	set checkNet($range_netof) 1
    }
    #
    # Check each parent network,  it must not be subnetted,  and its ranges
    # (new and old) may not overlap (or allow reserved addresses).
    #
    foreach net [array names checkNet] {
	#
	set cmd [list udb_fetch $net]
	foreach param {\
		net_start net_end net_bits net_mask net_type
	    } {
	    lappend cmd $anames($param)
	    upvar 0 ${net}($anames($param)) $param
	}
	eval $cmd
	#
	# Make sure net is not subnetted
	#
	if {![cequal Fixed $net_type] ||
		[unameit_address_mask_bits $net_mask] != $net_bits} {
	    unameit_error EINETSUBNETTED\
		[lindex $ranges 0] $anames(range_netof) $net
	}
	#
	# Check (ordered by starting address) list of all ranges on this net
	# for overlaps
	#
	foreach range [udb_inet_net_ranges $fname $net] {
	    upvar 0\
		${range}($anames(range_start)) range_start\
		${range}($anames(range_end)) range_end
	    #
	    udb_fetch $range $anames(range_start) $anames(range_end)
	    #
	    if {![info exists lastend]} {
		switch -- $inet_info($fname.node_zero) Reserved {
		    #
		    # Check that first range does not include
		    # a reserved address.
		    #
		    if {[cequal $range_start $net_start]} {
			#
			# OK if range is static and denies all nodes.
			#
			upvar 0\
			    ${range}($anames(range_type)) range_type\
			    ${range}($anames(range_devices)) range_devices
			#
			udb_fetch $range\
			    $anames(range_type) $anames(range_devices)
			#
			if {![cequal Static $range_type] ||
				![lempty $range_devices]} {
			    unameit_error EINETNODEZERO $range\
				$anames(range_start) $range_start\
				$anames(range_netof) $net
			}
		    }
		}
	    } elseif {[string compare $range_start $lastend] <= 0} {
		#
		# Range overlaps previous range
		#
		unameit_error EINETRANGEOVERLAP $range $last
	    }
	    set last $range
	    set lastend $range_end
	}
	#
	switch -- $inet_info($fname.last_node) Reserved {
	    #
	    # Check that last range does not include a reserved address.
	    #
	    if {[info exists lastend] && [cequal $lastend $net_end]} {
		#
		# OK if range is static and denies all nodes.
		# range_start and range_end should still be bound to
		# last range, but no harm in making sure!
		#
		upvar 0\
		    ${last}($anames(range_start)) range_start\
		    ${last}($anames(range_end)) range_end\
		    ${last}($anames(range_type)) range_type\
		    ${last}($anames(range_devices)) range_devices
		#
		udb_fetch $last $anames(range_type) $anames(range_devices)
		#
		if {![cequal Static $range_type] || ![lempty $range_devices]} {
		    unameit_error EINETLASTNODE $last\
			$anames(range_end) $range_end\
			$anames(range_netof) $net
		}
	    }
	}
    }
    #
    # Now do detailed checking of each range
    #
    foreach range $ranges {
	#
	# Bind simple variables to uuid array slots.
	#
	upvar 0\
	    ${range}($anames(range_start)) range_start\
	    ${range}($anames(range_end)) range_end\
	    ${range}($anames(range_type)) range_type\
	    ${range}($anames(range_devices)) range_devices
	#
	# Dynamic ranges allow no devices.  The range_devices list
	# is currently ignored,  but may be used for other things later.
	#
	set cmd\
	    [list udb_inet_check_range $fname $range $range_start $range_end]
	#
	switch -- $range_type Static {
	    foreach label $range_devices {
		if {[info exists inet_info(cname.$label)]} {
		    lappend cmd $inet_info(cname.$label)
		}
	    }
	}
	#
	# If range contains no bad nodes, try next
	#
	switch -- [set node [eval $cmd]] "" continue
	#
	# Oops, range loses
	#
	unameit_error EINETBADNODE $node $range $anames(range_devices)
    }
}

proc unameit_inet_check_nodes {fname nodes} {
    #
    upvar #0\
	UNAMEIT_ATTRIBUTE_UUID auuid\
	UNAMEIT_INET_INFO inet_info
    #
    foreach param {\
	    node_netof node_address\
	    net_start net_end net_bits net_mask net_type\
	    range_start range_end range_type range_devices\
	} {
	set anames($param) $inet_info($fname.$param)
    }
    #
    # Boilerplate:
    #
    foreach node $nodes {
	#
	# Get node info for each object,  hash parent networks
	# for checking.
	#
	udb_fetch $node $anames(node_netof) $anames(node_address)
	#
	upvar 0 ${node}($anames(node_netof)) node_netof
	#
	lappend checkNet($node_netof) $node
    }
    #
    # Check each net:
    #
    foreach net [array names checkNet] {
	#
	set cmd [list udb_fetch $net]
	foreach param {\
		net_start net_end net_bits net_mask net_type
	    } {
	    lappend cmd $anames($param)
	    upvar 0 ${net}($anames($param)) $param
	}
	eval $cmd
	#
	# Make sure net is not subnetted
	#
	if {![cequal Fixed $net_type] ||
		[unameit_address_mask_bits $net_mask] != $net_bits} {
	    unameit_error EINETSUBNETTED\
		[lindex $checkNet($net) 0] $anames(node_netof) $net
	}
	#
	foreach node $checkNet($net) {
	    upvar 0 ${node}($anames(node_address)) node_address
	    #
	    switch -- $inet_info($fname.node_zero) Reserved {
		#
		# Check that node does not have a reserved address.
		#
		if {[cequal $node_address $net_start]} {
		    unameit_error EINETNODEZERO $node\
			$anames(node_address) $node_address\
			$anames(node_netof) $net
		}
	    }
	    #
	    switch -- $inet_info($fname.node_zero) Reserved {
		#
		# Check that node does not have a reserved address.
		#
		if {[cequal $node_address $net_end]} {
		    unameit_error EINETLASTNODE $node\
			$anames(node_address) $node_address\
			$anames(node_netof) $net
		}
	    }
	    #
	    # Save address class for each address,  will do range
	    # on sorted addresses in bulk.
	    #
	    set address_node($node_address) $node
	}
	#
	# Get ranges for this network.  They are already known to
	# be non-overlapping and are returned in sorted order, so
	# the checks are easy.
	#
	set rangelist [udb_inet_net_ranges $fname $net]
	#
	# Make range_start and range_end aliases,
	# so they can re-aliased below
	#
	set empty ""
	upvar 0 empty range_start empty range_end
	#
	foreach address [lsort [array names address_node]] {
	    if {[string compare $address $range_start] < 0} continue
	    while {[string compare $address $range_end] > 0} {
		#
		# Fetch next range
		#
		set range [lvarpop rangelist]
		if {[cequal "" $range]} break
		#
		udb_fetch $range\
		    $anames(range_start)\
		    $anames(range_end)\
		    $anames(range_type)\
		    $anames(range_devices)
		#
		upvar 0\
		    ${range}($anames(range_start)) range_start\
		    ${range}($anames(range_end)) range_end\
		    ${range}($anames(range_type)) range_type\
		    ${range}($anames(range_devices)) range_devices
		#
		# Convert device list to class name array.
		#
		set ok() 1; unset ok
		switch -- $range_type Static {
		    foreach label $range_devices {
			if {[info exists inet_info(cname.$label)]} {
			    set ok($inet_info(cname.$label)) 1
			}
		    }
		}
	    }
	    #
	    if {[cequal "" $range]} break
	    #
	    # We are inside the current range,  check device class
	    #
	    upvar 0 address_node($address) item
	    upvar 0 ${item}(Class) item_class
	    while {![info exists ok($item_class)]} {
		#
		# If the owner of a node is a node,  try that
		# recursively  (e.g. treat router interfaces as routers!)
		#
		if {![info exists ${item}(owner)]} {
		    udb_fetch $item owner
		}
		upvar 0 ${item}(owner) item
		if {[cequal "" $item]} break
		udb_fetch $item owner
		upvar 0 ${item}(Class) item_class
		if {![info exists auuid($item_class.$anames(node_address))]} {
		    break
		}
	    }
	    if {[info exists ok($item_class)]} continue
	    #
	    # Oops: node loses.
	    #
	    unameit_error EINETBADNODE\
		$address_node($address) $range $anames(range_devices)
	}
    }
}
