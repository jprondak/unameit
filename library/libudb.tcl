#
# Copyright (c) 1997 Enterprise Systems Management Corp.
#
# This file is part of UName*It.
#
# UName*It is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later
# version.
#
# UName*It is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with UName*It; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
# $Id: libudb.tcl,v 1.64.20.10 1997/10/11 00:54:17 viktor Exp $

#################### Schema modification code follows ####################
#
# This is the global schema modification routine. It calls all the other
# routines when doing schema validation and modification.
#
proc unameit_change_schema {} {
    upvar #0 UNAMEIT_SUPS old_sups
    upvar #0 UNAMEIT_ATTRIBUTE_ITEMS old_attributes
    upvar #0 UNAMEIT_FAMILY_ITEMS old_families
    #
    # Load the new schema at this level
    #
    unameit_load_schema
    #
    # Do an intersection between the old and new class and attribute uuids.
    # These are used a lot in the following routines
    #
    lassign [intersect3 [array names old_sups] [array names UNAMEIT_SUPS]]\
	deleted_classes common_classes new_classes
    lassign [intersect3 $old_attributes $UNAMEIT_ATTRIBUTE_ITEMS]\
	deleted_attributes common_attributes new_attributes
    lassign [intersect3 $old_families $UNAMEIT_FAMILY_ITEMS]\
	deleted_families common_families new_families

    #
    # If schema is changed,  run the brutal algorithm.
    #
    if {[unameit_do_global_validation [info level]]} {
	#
	# Initialize empty index script
	#
	set index_script ""
	#
	# If the role class (name, owner) is already indexed,  add roles
	# for any new data attributes, otherwise wait for data restore
	# to finish, before adding all the indices.
	#
	set add_indices [umeta_has_index role]
	#
	unameit_deconflict_schema [info level]
	unameit_change_classes [info level]
	unameit_change_superclasses [info level]
	unameit_reconflict_schema [info level] $add_indices
	#
	# Run all the index creation commands generated by the above code.
	# Index creation runs best,  when left till last.
	#
	eval $index_script
    }
    unameit_process_collision_tables [info level]
    unameit_process_autoints [info level]
    unameit_process_families [info level]
}

proc unameit_do_global_validation {level} {
    upvar #$level\
	deleted_classes deleted_classes\
	new_classes new_classes\
	deleted_attributes deleted_attributes\
	new_attributes new_attributes\
	new_domain new_domain
    #
    unameit_check_classes $level
    unameit_check_deleted_attributes $level
    unameit_check_collisions $level
    unameit_check_triggers $level
    unameit_check_attribute_inheritance $level
    unameit_check_name_attributes $level
    unameit_check_display_attributes $level
    unameit_check_autoints $level
    unameit_check_pointer_domains $level
    unameit_check_pointer_integrity $level
    #
    if {[array size new_domain] > 0} {
	return 1
    }
    if {![lempty [concat $deleted_classes $new_classes]]} {
	return 1
    }
    if {[unameit_check_superclasses $level]} {
	return 1
    }
    #
    # Check for deletion or creation of defining attributes,  inherited
    # attributes do not explicitly change the schema (except as detected
    # by the 'new_domain' check above)
    #
    foreach attribute $deleted_attributes {
	upvar #0 $attribute attribute_item
	if {[info exists attribute_item(unameit_attribute_name)]} {return 1}
    }
    foreach attribute $new_attributes {
	upvar #$level $attribute attribute_item
	if {[info exists attribute_item(unameit_attribute_name)]} {return 1}
    }
    return 0
}

proc unameit_check_no_instances {cname args} {
    set constraints {}
    set opts {}
    foreach aname $args {
	switch -glob -- $aname {
	    -* {
		lappend opts $aname
	    }
	    default {
		lappend constraints [list $aname !=]
	    }
	}
    }
    eval unameit_qbe $opts -maxRows 0 $cname $constraints
}

proc unameit_check_classes {level} {
    upvar #$level deleted_classes deleted_classes
    upvar #$level common_classes common_classes
    #
    foreach class $deleted_classes {
	upvar #0 $class class_item
	set cname $class_item(unameit_class_name)
	switch -- $class_item(Class) {
	    unameit_data_class {
		#
		# A data class is being deleted
		#
		if {[catch {unameit_check_no_instances $cname -deleted}]} {
		    unameit_error ECLASSHASINSTANCES $class
		}
	    }
	    default {
		error "Unexpected deleted class $cname"
	    }
	}
    }
    foreach class $common_classes {
	upvar #0 $class class_item
	upvar #$level $class new_class_item
	switch -- $class_item(unameit_class_readonly)\
	    $new_class_item(unameit_class_readonly) continue
	#
	# Check that transition to/from readonly only happen when class
	# is empty.
	#
	set cname $class_item(unameit_class_name)
	if {[catch {unameit_check_no_instances $cname}]} {
	    unameit_error ECLASSHASINSTANCES $class
	}
    }
}

proc unameit_check_deleted_attributes {level} {
    upvar #0 UNAMEIT_ATTRIBUTES old_attributes
    upvar #$level UNAMEIT_ISA new_isa
    upvar #$level common_classes common_classes

    foreach class $common_classes {
	upvar #0 $class class_item
	set cname $class_item(unameit_class_name)
	#
	# Only data classes may have deleted attributes
	#
	switch -- $class_item(Class) unameit_data_class {} default continue
	#
	# Common classes still exist in new schema (by definition)
	#
	upvar #$level $class new_class_item
	#
	# Loop over each old attribute checking for possible data loss
	#
	foreach attribute $old_attributes($class) {
	    upvar #0 $attribute attribute_item
	    set defining [info exists attribute_item(unameit_attribute_name)]
	    if {$defining} {
		set defining_attribute $attribute
	    } else {
		set defining_attribute\
		    $attribute_item(unameit_attribute_whence)
	    }
	    upvar #0 $defining_attribute defining_attribute_item
	    set aname $defining_attribute_item(unameit_attribute_name)
	    #
	    upvar #$level $defining_attribute new_attribute_item
	    if {![array exists new_attribute_item]} {
		#
		# Defining attribute has been deleted, if looking at defining
		# class,  make sure that no data is going to be lost in any
		# subclass.
		#
		set defining_class\
		    $defining_attribute_item(unameit_attribute_class)
		if {![cequal $class $defining_class]} continue
		if {[catch {
			unameit_check_no_instances $cname -all -deleted $aname
			}]} {
		    unameit_error EATTRHASINSTANCES $class $attribute
		}
	    } else {
		#
		# Attribute is not physically deleted if it still inherited
		# from new defining_class
		#
		set defining_class\
		    $new_attribute_item(unameit_attribute_class)
		#
		if {[info exists new_isa($defining_class.$class)]} continue
		#
		# Check for data loss
		#
		if {[catch {
			unameit_check_no_instances $cname -deleted $aname
			}]} {
		    unameit_error EATTRHASINSTANCES $class $attribute
		}
	    }
	}
    }
}

#
# This routine checks that each new inherited attribute actually
# aplies to a class that is a subclass of the defining class in the metadata.
#
proc unameit_check_attribute_inheritance {level} {
    upvar #$level UNAMEIT_ATTRIBUTE_ITEMS new_attributes
    upvar #$level UNAMEIT_ISA new_isa

    foreach attribute $new_attributes {
	upvar #$level $attribute attribute_item
	#
	# If attribute is not inherited continue
	#
	if {[info exists attribute_item(unameit_attribute_name)]} continue
	#
	# Bind defining attribute
	#
	set defining_attribute $attribute_item(unameit_attribute_whence)
	upvar #$level $defining_attribute defining_attribute_item
	#
	# Get class and defining_class
	#
	set class $attribute_item(unameit_attribute_class)
	set defining_class $defining_attribute_item(unameit_attribute_class)
	#
	# Make sure class is a subclass of defining class.
	#
	if {![info exists new_isa($defining_class.$class)]} {
	    unameit_error ENOTINHERITED\
		$attribute unameit_attribute_whence $defining_attribute
	}
    }
}


#
# Validate name attributes of each data class
#
proc unameit_check_name_attributes {level} {
    upvar #$level UNAMEIT_SUPS sups
    upvar #$level UNAMEIT_ISA isa
    #
    foreach class [array names sups] {
	upvar #$level $class class_item
	#
	# Only look at data classes
	#
	switch -- $class_item(Class) unameit_data_class {} default continue
	#
	set cname $class_item(unameit_class_name)
	#
	foreach attribute $class_item(unameit_class_name_attributes) {
	    #
	    # Should point at defining attribute record
	    #
	    upvar #$level $attribute attribute_item
	    set defining_class $attribute_item(unameit_attribute_class)
	    #
	    # Make sure we are a subclass of the defining class
	    #
	    if {![info exists isa($defining_class.$class)]} {
		unameit_error ENOTINHERITED $class\
		    unameit_class_name_attributes $attribute
	    }
	}
    }
}

#
# Validate display attributes of each data class
#
proc unameit_check_display_attributes {level} {
    upvar #$level UNAMEIT_SUPS sups
    upvar #$level UNAMEIT_ISA isa
    #
    foreach class [array names sups] {
	upvar #$level $class class_item
	#
	# Only look at data classes
	#
	switch -- $class_item(Class) unameit_data_class {} default continue
	#
	set cname $class_item(unameit_class_name)
	#
	foreach attribute $class_item(unameit_class_display_attributes) {
	    #
	    # Should point at defining attribute record
	    #
	    upvar #$level $attribute attribute_item
	    if {[info exists dup($attribute)]} {
		unameit_error EDUPELEMENT $class\
		    unameit_class_display_attributes $attribute
	    }
	    set dup($attribute) ""
	    set defining_class $attribute_item(unameit_attribute_class)
	    #
	    # Make sure we are a subclass of the defining class
	    #
	    if {![info exists isa($defining_class.$class)]} {
		unameit_error ENOTINHERITED $class\
		    unameit_class_display_attributes $attribute
	    }
	}
	#
	# Clear duplicate detection array.
	#
	set dup() ""; unset dup
    }
}

proc unameit_check_autoints {level} {
    upvar #0 UNAMEIT_AUTOINTS old_autos
    upvar #$level UNAMEIT_AUTOINTS new_autos
    #
    set common [intersect $old_autos $new_autos]
    #
    # Old autoints can go since they take the data and all the state with
    # them.
    # New ones can be created since they do not yet have any instances.
    # Just check for instances of modified ones.
    #
    foreach auto $common {
	upvar #0 $auto auto_item
	upvar #$level $auto new_auto_item
	#
	# Only check for lack of instances when the level has changed
	#
	switch --\
	    $auto_item(unameit_autoint_attribute_level)\
	    $new_auto_item(unameit_autoint_attribute_level) continue
	#
	set aname $auto_item(unameit_attribute_name)
	set class $auto_item(unameit_attribute_class)
	upvar #0 $class class_item
	set cname $class_item(unameit_class_name)
	#
	if {[catch {unameit_check_no_instances $cname -all $aname}]} {
	    unameit_error EATTRHASINSTANCES $class $auto
	}
    }
}

#
# Collision rules may not be deleted or added,
# if they imply existing collisions for an undeleted collision table.
#
proc unameit_check_collisions {level} {
    upvar #0\
	UNAMEIT_COLLISION_RULE old_rules\
	UNAMEIT_ATTRIBUTE_UUID old_auuid
    upvar #$level\
	UNAMEIT_COLLISION_RULE new_rules\
	UNAMEIT_ATTRIBUTE_UUID new_auuid
    #
    lassign [intersect3 [array names old_rules] [array names new_rules]]\
	deleted common new
    #
    foreach rule $deleted {
	upvar #0 $rule rule_item
	#
	set collision_table $rule_item(unameit_collision_table)
	set colliding_class $rule_item(unameit_colliding_class)
	#
	upvar #$level $collision_table new_table_item
	if {![array exists new_table_item]} {
	    #
	    # Collision table was deleted. Continue.
	    #
	    continue
	}
	#
	# Get old metadata record for colliding class (need name for qbe)
	#
	upvar #0 $colliding_class colliding_class_item
	set cname $colliding_class_item(unameit_class_name)
	#
	# Collision table still exists.
	# Check for any existing collisions for this rule.
	#
	set cmd [list unameit_check_no_instances $cname]
	set alist {}
	foreach attribute $rule_item(unameit_collision_attributes) {
	    #
	    # Attributes are defining
	    #
	    upvar #0 $attribute attribute_item
	    lappend cmd $attribute_item(unameit_attribute_name)
	}
	if {[catch $cmd]} {
	    unameit_error ECOLLISIONRULEINUSE $rule\
		unameit_colliding_class $colliding_class
	}
    }
    foreach rule $new {
	upvar #$level $rule rule_item
	#
	set colliding_class $rule_item(unameit_colliding_class)
	upvar #0 $colliding_class old_class_item
	upvar #$level $colliding_class new_class_item
	set cname $new_class_item(unameit_class_name)
	#
	set check_instances [array exists old_class_item]
	set cmd [list unameit_check_no_instances $cname]
	#
	set cs $rule_item(unameit_collision_cell_strength)
	set os $rule_item(unameit_collision_org_strength)
	set gs $rule_item(unameit_collision_global_strength)
	set unpromoted [cequal $cs.$os.$gs None.None.None]
	set owner_in_key 0
	#
	foreach attribute $rule_item(unameit_collision_attributes) {
	    #
	    # Attributes are defining
	    #
	    upvar #$level $attribute attribute_item
	    set aname $attribute_item(unameit_attribute_name)
	    switch -- $aname owner {
		set owner_in_key 1
	    }
	    if {![info exists new_auuid($cname.$aname)]} {
		unameit_error ENOTINHERITED\
		    $rule unameit_collision_attributes $attribute
	    }
	    #
	    # If attribute is newly inherited,  it cannot yet have
	    # NON NULL values.
	    #
	    if {![info exists old_auuid($cname.$aname)]} {
		set check_instances 0
	    }
	    lappend cmd $aname
	}
	#
	if {$unpromoted == 0 && $owner_in_key == 0} {
	    unameit_error ECOLLISIONOWNERMISSING $rule\
		unameit_collision_attributes
	}
	#
	if {$check_instances && [catch $cmd]} {
	    unameit_error ECOLLISIONRULEINUSE $rule\
		unameit_colliding_class $colliding_class
	}
    }
}

#
proc unameit_check_triggers {level} {
    upvar #$level\
	UNAMEIT_TRIGGERS triggers\
	UNAMEIT_ATTRIBUTE_UUID auuid
    #
    foreach trigger $triggers {
	upvar #$level $trigger trigger_item
	#
	set trigger_class $trigger_item(unameit_trigger_class)
	upvar #$level $trigger_class class_item
	set cname $class_item(unameit_class_name)
	#
	foreach alist {unameit_trigger_attributes unameit_trigger_computes} {
	    foreach attribute $trigger_item($alist) {
		#
		# Attributes are defining
		#
		upvar #$level $attribute attribute_item
		set aname $attribute_item(unameit_attribute_name)
		if {![info exists auuid($cname.$aname)]} {
		    unameit_error ENOTINHERITED $trigger $alist $attribute
		}
	    }
	}
    }
}

#
# This routine returns the type of a unameit_attribute (string, integer or
# object).  The type is an attribute of the metadata of syntax class
# of the attribute
#
proc unameit_attribute_type {attribute {level 0}} {
    upvar #$level UNAMEIT_CLASS_UUID cuuid
    #
    upvar #$level $attribute attribute_item
    upvar #$level $cuuid($attribute_item(Class)) class_item
    set class_item(unameit_syntax_type)
}

#
# This function takes a super and subclass list and returns the classes in
# top down order.
#
proc unameit_sort_top_down {upvar downvar} {
    #
    # Copy the arrays,  we need to modifying them,  but do not want to change
    # the caller's data.
    #
    upvar 1 $upvar upsrc
    upvar 1 $downvar downsrc
    array set up [array get upsrc]
    array set down [array get downsrc]
    #
    # Iteratively extract top level items (those with nothing above them).
    #
    set result {}
    while {[array size up] > 0} {
	foreach elem [array names up] {
	    if {[llength $up($elem)] != 0} continue
	    #
	    # Remove this element from the up list of every inferior
	    #
	    foreach subelem $down($elem) {
		lvarpop up($subelem) [lsearch -exact $up($subelem) $elem]
	    }
	    #
	    # Append to result and remove from up array
	    #
	    lappend result $elem
	    unset up($elem)
	}
    }
    set result
}

proc unameit_deconflict_class {class level} {
    upvar #0 UNAMEIT_ATTRIBUTES attributes
    upvar #0 UNAMEIT_CLASS_UUID cuuid
    upvar #$level UNAMEIT_ISA new_isa
    upvar #$level new_domain new_domain
    #
    upvar #0 $class class_item
    #
    set refintAttr unameit_pointer_attribute_ref_integrity
    set cname $class_item(unameit_class_name)
    umeta_edit_class $cname
    #
    foreach attribute $attributes($class) {
	#
	# Loop over each defined or inherited attribute
	#
	upvar #0 $attribute attribute_item
	set attribute_class $attribute_item(unameit_attribute_class)
	set defining [info exists attribute_item(unameit_attribute_name)]
	if {$defining} {
	    set defining_attribute $attribute
	} else {
	    set defining_attribute\
		$attribute_item(unameit_attribute_whence)
	}
	upvar #0 $defining_attribute defining_attribute_item
	#
	# Bind defining data
	#
	set aname $defining_attribute_item(unameit_attribute_name)
	set defining_class $defining_attribute_item(unameit_attribute_class)
	#
	# Don't want to mess with attributes inherited from
	# the `unameit_item' class.  `uuid' must stay inherited
	# otherwise `db_find_unique' will not find items in subclasses.
	#
	if {[cequal $defining_class $cuuid(unameit_item)]} continue
	#
	# If the attribute is to be deleted,  do so here.
	#
	#	If attribute will no longer be defined drop it.
	#	(and drop relation class if suitable pointer)
	#
	set class_stable [info exists new_isa($class.$class)]
	upvar #$level $defining_attribute new_attribute_item
	set attribute_stable [info exists new_attribute_item]
	set inheritance_stable [info exists new_isa($defining_class.$class)]
	set domain_change [info exists new_domain($class.$defining_attribute)]
	#
	if {!$class_stable || !$attribute_stable || !$inheritance_stable ||
		$domain_change} {
	    umeta_drop_attribute $aname
	    if {[cequal $class $defining_class] &&
		    [info exists attribute_item($refintAttr)]} {
		umeta_drop_class "relation/$aname"
	    }
	    continue
	}
	if {[cequal $class $defining_class]} continue
	#
	# Rename to unique temporary name
	#
	set tmp_name "${cname}.${aname}"
	umeta_rename_attribute $aname $tmp_name
    }
    umeta_finish_class
}

proc unameit_reconflict_class {class level add_indices} {
    upvar #0 UNAMEIT_ISA old_isa
    upvar #0 UNAMEIT_CLASS_UUID cuuid
    upvar #$level UNAMEIT_ATTRIBUTES attributes
    upvar #$level UNAMEIT_MULTIPLICITY amul
    upvar #$level UNAMEIT_SYNTAX attribute_syntax
    upvar #$level new_domain new_domain
    #
    upvar #$level index_script index_script
    #
    set refintAttr unameit_pointer_attribute_ref_integrity
    set new_relations {}
    upvar #$level $class class_item
    set cname $class_item(unameit_class_name)
    umeta_edit_class $cname
    #
    # Fix each new attribute in turn
    #
    foreach attribute $attributes($class) {
	#
	# Get attribute name and defining record
	#
	upvar #$level $attribute attribute_item
	set attribute_class $attribute_item(unameit_attribute_class)
	set defining [info exists attribute_item(unameit_attribute_name)]
	if {$defining} {
	    set defining_attribute $attribute
	} else {
	    set defining_attribute\
		$attribute_item(unameit_attribute_whence)
	}
	upvar #$level $defining_attribute defining_attribute_item
	set aname $defining_attribute_item(unameit_attribute_name)
	set defining_class $defining_attribute_item(unameit_attribute_class)
	#
	# Don't want to mess with attributes inherited from
	# the `unameit_item' schema class.  `uuid' must stay inherited
	# otherwise `db_find_unique' will not find items in subclasses.
	#
	if {[cequal $defining_class $cuuid(unameit_item)]} {
	    if {[cequal $attribute_class $cuuid(unameit_item)] &&
		    [uplevel #0 array exists $attribute]} {
		#
		# Nothing to do if stable attribute of unameit_item
		#
		continue
	    }
	    #
	    # It should be possible to override the "syntax" of the
	    # "comment" attribute.   Since inheritance of attributes
	    # from unameit_item is stable,  we need/must not "shadow" it.
	    #
	    switch -- $aname comment continue
	    #
	    # Illegal change of unameit_item schema
	    #
	    unameit_error EFIXEDSCHEMA $cuuid(unameit_item) $attribute
	}
	#
	# Is it an  old attribute of the same domain?
	#
	upvar #0 $class old_class_item
	upvar #0 $defining_attribute old_attribute_item
	set class_stable [array exists old_class_item]
	set attribute_stable [array exists old_attribute_item]
	set inheritance_stable [info exists old_isa($defining_class.$class)]
	set domain_change [info exists new_domain($class.$defining_attribute)]
	#
	if {$class_stable && $attribute_stable && $inheritance_stable &&
		!$domain_change} {
	    if {[cequal $class $defining_class]} continue
	    #
	    # This attribute is old rename it to original name
	    #
	    set tmp_name "${cname}.${aname}"
	    umeta_rename_attribute $tmp_name $aname
	} else {
	    #
	    # New attribute
	    #
	    umeta_add_attribute $aname $amul($aname)\
		[unameit_domain_string $class $defining_attribute $level]
	    if {[cequal $class $defining_class] &&
		    [info exists attribute_item($refintAttr)]} {
		lappend new_relations $aname
	    }
	    if {!$add_indices} continue
	    if {![cequal $class_item(unameit_class_readonly) No]} continue
	    if {![cequal $amul($aname) Scalar]} continue
	    switch -- $attribute_syntax($cname.$aname) {
		address -
		autoint -
		choice -
		enum -
		integer -
		pointer -
		string -
		time {
		    append index_script\
			"[list umeta_add_index $cname $aname]\n"
		}
	    }
	}
    }
    umeta_finish_class
    foreach aname $new_relations {
	set relcname "relation/$aname"
	umeta_create_class $relcname
	umeta_add_class_attribute nextfree Scalar OBJECT
	umeta_add_attribute nextfree Scalar OBJECT
	umeta_add_attribute lhs Scalar OBJECT
	umeta_add_attribute rhs Scalar OBJECT
	umeta_add_attribute prev Scalar OBJECT
	umeta_add_attribute next Scalar OBJECT
	if {[cequal $amul($aname) Scalar]} {
	    umeta_constrain_unique u(lhs) lhs
	} elseif {$add_indices} {
	    append index_script\
		"[list umeta_add_index $relcname lhs]\n"
	}
	umeta_finish_class
    }
}

#
# Rename all attributes to class specific name in order to remove
# potential inheritance conflicts while changing the superclass hierarchy.
# Delete extant attributes as necessary
#
proc unameit_deconflict_schema {level} {
    upvar #0 UNAMEIT_SUBS subs
    upvar #0 UNAMEIT_SUPS sups
    upvar #0 UNAMEIT_CLASS_UUID cuuid
    #
    # Compute a class hierarchy of just the data classes
    #
    set i_class $cuuid(unameit_item)
    set di_class $cuuid(unameit_data_item)
    set dsups($i_class) {}
    set dsubs($i_class) [concat $di_class $subs($di_class)]
    foreach class $dsubs($i_class) {
	set dsups($class) $sups($class)
	set dsubs($class) $subs($class)
    }
    #
    # Deconflict in old top down order
    #
    foreach class [unameit_sort_top_down dsups dsubs] {
	unameit_deconflict_class $class $level
    }
}

#
# Rename attributes back to correct names (from the bottom up)
# and add any new attributes in one pass.
#
proc unameit_reconflict_schema {level add_indices} {
    upvar #$level UNAMEIT_SUBS subs
    upvar #$level UNAMEIT_SUPS sups
    upvar #$level UNAMEIT_CLASS_UUID cuuid
    #
    # Compute a class hierarchy of just the data classes
    #
    set i_class $cuuid(unameit_item)
    set di_class $cuuid(unameit_data_item)
    #
    set dsups($i_class) {}
    set dsubs($i_class) [concat $di_class $subs($di_class)]
    foreach class $dsubs($i_class) {
	set dsups($class) $sups($class)
	set dsubs($class) $subs($class)
    }
    #
    # Reconflict in new bottom up order
    #
    foreach class [unameit_sort_top_down dsubs dsups] {
	unameit_reconflict_class $class $level $add_indices
    }
}

proc unameit_change_classes {level} {
    upvar #$level deleted_classes deleted_classes
    upvar #$level new_classes new_classes
    upvar #$level common_classes common_classes
    #
    # First delete all the requested (to delete) classes.
    #
    foreach class $deleted_classes {
	upvar #0 $class class_item
	set cname $class_item(unameit_class_name)
	umeta_drop_class $cname
    }
    #
    # Finally create new classes,
    # making data classes subclasses of unameit_data_item
    #
    foreach class $new_classes {
	upvar #$level $class class_item
	set cname $class_item(unameit_class_name)
	umeta_create_class $cname
	switch -- $class_item(Class) unameit_data_class {
	    umeta_add_superclass unameit_data_item
	}
	umeta_finish_class
    }
}

#
# Modify inheritance hierarchy
#
proc unameit_check_superclasses {level} {
    upvar #$level common_classes common_classes
    #
    # See if class hierarchy is stable
    #
    foreach class $common_classes {
	upvar #0 $class old_class_item
	upvar #$level $class new_class_item
	#
	lassign [intersect3 $old_class_item(unameit_class_supers)\
		    $new_class_item(unameit_class_supers)]\
	    deleted common new
	#
	foreach super $deleted {
	    upvar #0 $super super_item
	    set super_name $super_item(unameit_class_name)
	    #
	    switch -- $super_name unameit_item - unameit_data_item continue
	    return 1
	}
	#
	foreach super $new {
	    upvar #$level $super super_item
	    set super_name $super_item(unameit_class_name)
	    #
	    switch -- $super_name unameit_item - unameit_data_item continue
	    return 1
	}
    }
    return 0
}

#
# Modify inheritance hierarchy
#
proc unameit_change_superclasses {level} {
    upvar #$level common_classes common_classes
    upvar #$level new_classes new_classes
    #
    # Compute lists of superclass drops and adds.
    #
    foreach class $common_classes {
	upvar #0 $class old_class_item
	upvar #$level $class new_class_item
	set cname $old_class_item(unameit_class_name)
	#
	lassign [intersect3 $old_class_item(unameit_class_supers)\
		    $new_class_item(unameit_class_supers)]\
	    deleted common new
	#
	# Drop each extant superclass link.
	#
	foreach super $deleted {
	    upvar #$level $super super_item
	    if {![info exists super_item]} {
		#
		# Superclass has been dropped from schema,  so no need
		# to drop it as superclass
		#
		continue
	    }
	    set super_name $super_item(unameit_class_name)
	    #
	    # Ignore explicit inheritance of unameit_item and unameit_data_item
	    #
	    switch -- $super_name unameit_item - unameit_data_item continue
	    lappend drop($cname) $super_name
	}
	foreach super $new {
	    #
	    # If it is a super in the new schema,  then it exists
	    #
	    upvar #$level $super super_item
	    set super_name $super_item(unameit_class_name)
	    #
	    # Ignore explicit inheritance of unameit_item and unameit_data_item
	    #
	    switch -- $super_name unameit_item - unameit_data_item continue
	    lappend add($cname) $super_name
	}
    }
    #
    # Add new links for new classes
    #
    foreach class $new_classes {
	upvar #$level $class class_item
	set cname $class_item(unameit_class_name)
	#
	foreach super $class_item(unameit_class_supers) {
	    upvar #$level $super super_item
	    set super_name $super_item(unameit_class_name)
	    #
	    # Ignore explicit inheritance of unameit_item and unameit_data_item
	    #
	    switch -- $super_name unameit_item - unameit_data_item continue
	    lappend add($cname) $super_name
	}
    }
    #
    # First do all the drops, so as to avoid possible loops when doing the adds
    #
    foreach cname [array names drop] {
	umeta_edit_class $cname
	foreach super $drop($cname) {
	    umeta_drop_superclass $super
	}
	umeta_finish_class
    }
    #
    # Now add all the new links
    #
    foreach cname [array names add] {
	umeta_edit_class $cname
	foreach super $add($cname) {
	    umeta_add_superclass $super
	}
	umeta_finish_class
    }
}

#
# Build a UniSQL/X domain string for an attribute
# For object attributes can only be called if the domain is changing
# after calling domain compute procs.
#
proc unameit_domain_string {class attribute level} {
    upvar #$level UNAMEIT_POINTER_DOMAIN new_domain
    upvar #$level UNAMEIT_MULTIPLICITY amul
    upvar #$level UNAMEIT_ATTRIBUTE_TYPE attribute_type

    upvar #$level $attribute attribute_item
    if {[info exists attribute_item(unameit_attribute_name)]} {
	set defining_attribute $attribute
    } else {
	set defining_attribute $attribute_item(unameit_attribute_whence)
    }
    upvar #$level $defining_attribute defining_attribute_item
    set aname $defining_attribute_item(unameit_attribute_name)

    switch -- $amul($aname) {
	Set {
    	    set prefix "set of "
	}
	Sequence {
    	    set prefix "sequence of "
	}
	Scalar {
	    set prefix ""
	}
    }
    switch -- $attribute_type($aname) {
	String {
	    set domain string
	}
	Integer {
    	    set domain integer
	}
	Object {
	    upvar #$level $new_domain($class.$attribute) domain_item
    	    set domain "\"$domain_item(unameit_class_name)\""
	}
    }
    return "$prefix$domain"
}

#
# Collision tables have implicit attributes with no metadata,  we will
# deal with these here.
#
proc unameit_process_collision_tables {level} {
    upvar #0 UNAMEIT_COLLISION_TABLE_ITEMS old_collision_tables
    upvar #$level UNAMEIT_COLLISION_TABLE_ITEMS new_collision_tables

    lassign [intersect3 $old_collision_tables $new_collision_tables]\
	deleted common new
    #
    # Drop deleted collision tables
    #
    foreach table $deleted {
	upvar #0 $table old_table_item
	set cname $old_table_item(unameit_collision_name)
	umeta_drop_class "collision/$cname"
    }
    #
    # Build any new collision tables
    #
    foreach table $new {
	upvar #$level $table table_item
	set cname $table_item(unameit_collision_name)
	switch -- $table_item(Class) {
	    unameit_data_collision_table {
		set domain "set of unameit_data_item"
	    }
	    default {
		error "unexpected collision table domain: $table_item(Class)"
	    }
	}
	umeta_create_class "collision/$cname"
	#
	umeta_add_class_attribute nextfree Scalar OBJECT
	umeta_add_attribute nextfree Scalar OBJECT
	umeta_add_attribute key Scalar string
	foreach strength {strong normal weak} {
	    umeta_add_attribute $strength Set $domain
	}
	umeta_constrain_unique u(key) key
	umeta_finish_class
#	umeta_cluster collision/role_name "collision/$cname"
    }
}

proc unameit_process_autoints {level} {
    upvar #0 UNAMEIT_AUTOINTS old_autos
    upvar #$level UNAMEIT_AUTOINTS new_autos
    #
    lassign [intersect3 $old_autos $new_autos] deleted common new
    #
    foreach auto $deleted {
	upvar #0 $auto auto_item
	set aname $auto_item(unameit_attribute_name)
	#
	umeta_drop_class "range/$aname/used"
	umeta_drop_class "range/$aname/slot"
    }
    #
    foreach auto $new {
	upvar #$level $auto auto_item
	set aname $auto_item(unameit_attribute_name)
	upvar #$level $auto_item(unameit_attribute_class) class_item
	set cname $class_item(unameit_class_name)
	#
	umeta_create_class "range/$aname/used"
	umeta_add_class_attribute nextfree Scalar OBJECT
	umeta_add_attribute nextfree Scalar OBJECT
	umeta_add_attribute range_owner Scalar unameit_data_item
	umeta_add_attribute range_blocks\
	    Sequence "sequence of unameit_range_block"
	umeta_constrain_unique u(range_owner) range_owner
	umeta_finish_class
	#
	umeta_create_class "range/$aname/slot"
	umeta_add_class_attribute nextfree Scalar OBJECT
	umeta_add_attribute nextfree Scalar OBJECT
	umeta_add_attribute range_key Scalar String
	umeta_add_attribute range_items Set "set of \"$cname\""
	umeta_constrain_unique u(range_key) range_key
	umeta_finish_class
    }
}

proc unameit_process_families {level} {
    upvar #$level deleted_families deleted_families
    upvar #$level new_families new_families
    #
    # First do the deletions
    #
    foreach family $deleted_families {
	upvar #0 $family family_item
	set fname family/$family_item(unameit_family_name)
	umeta_drop_class $fname/block
	umeta_drop_class $fname/slot
	#
	# Modify network and range classes to drop pointer to block
	#
	upvar #$level $family_item(unameit_net_class) nclass_item
	if {[array exists nclass_item]} {
	    upvar #0 $family_item(unameit_net_class) nclass_item
	    set ncname $nclass_item(unameit_class_name)
	    umeta_edit_class $ncname
		umeta_drop_attribute inet/block
	    umeta_finish_class
	}
	#
	upvar #$level $family_item(unameit_range_class) rclass_item
	if {[array exists rclass_item]} {
	    upvar #0 $family_item(unameit_range_class) rclass_item
	    set rcname $rclass_item(unameit_class_name)
	    umeta_edit_class $rcname
		umeta_drop_attribute inet/block
	    umeta_finish_class
	}
    }
    #
    # Then the creates.
    #
    foreach family $new_families {
	upvar #$level $family family_item
	set fname family/$family_item(unameit_family_name)
	set bits [expr {$family_item(unameit_address_octets) * 8}]
	#
	# Create net block class
	#
	umeta_create_class $fname/block
	    #
	    umeta_add_attribute bits Scalar INTEGER
	    umeta_add_attribute super Scalar OBJECT
	    umeta_add_attribute nets Sequence "SEQUENCE OF OBJECT"
	    umeta_add_attribute subs Sequence "SEQUENCE OF OBJECT"
	    umeta_add_attribute ranges Sequence "SEQUENCE OF OBJECT"
	    #
	    # Special data for blocks corresponding to networks
	    #
	    umeta_add_attribute net_nodes Scalar INTEGER
	    umeta_add_attribute net_anode Scalar OBJECT
	    umeta_add_attribute net_subnets Scalar INTEGER
	    umeta_add_attribute net_asubnet Scalar OBJECT
	    umeta_add_attribute net_ranges Sequence "SEQUENCE OF OBJECT"
	    #
	    # Root block
	    #
	    umeta_add_class_attribute root_object Scalar OBJECT
	    #
	    # Class and node links for freelist
	    #
	    umeta_add_class_attribute nextfree Scalar OBJECT
	    umeta_add_attribute nextfree Scalar OBJECT
	    #
	umeta_finish_class
	#
	# Create node slot class
	#
	umeta_create_class $fname/slot
	    #
	    # Bits is a shared constant for node slots
	    #
	    umeta_add_shared_attribute bits Scalar INTEGER I$bits
	    #
	    umeta_add_attribute super Scalar OBJECT
	    umeta_add_attribute nodes Sequence "SEQUENCE OF OBJECT"
	    #
	    # "stamp" is a timestamp of when the node last became empty.
	    # The empty nodes stick around so long as the network hierarchy
	    # above them does not change.  (Deleted whenever any contained
	    # node would have been reparented).
	    #
	    umeta_add_attribute stamp Scalar INTEGER
	    #
	    # Class and node links for free list
	    #
	    umeta_add_class_attribute nextfree Scalar OBJECT
	    umeta_add_attribute nextfree Scalar OBJECT
	    #
	umeta_finish_class
	#
	# Modify network and range classes to add pointer to block
	#
	upvar #$level $family_item(unameit_net_class) nclass_item
	set ncname $nclass_item(unameit_class_name)
	umeta_edit_class $ncname
	    umeta_add_attribute inet/block Scalar OBJECT
	umeta_finish_class
	#
	upvar #$level $family_item(unameit_range_class) rclass_item
	set rcname $rclass_item(unameit_class_name)
	umeta_edit_class $rcname
	    umeta_add_attribute inet/block Scalar OBJECT
	umeta_finish_class
    }
}

#
# See if attribute domain is changing.
# Make sure that attributes with a changed domain have no (non NULL) data
#
proc unameit_check_domain_change {class attribute domain level} {
    upvar #0 UNAMEIT_POINTER_DOMAIN old_domain
    upvar #$level UNAMEIT_POINTER_DOMAIN computed_domain
    upvar #$level new_domain new_domain
    #
    set computed_domain($class.$attribute) $domain
    #
    if {![info exists old_domain($class.$attribute)]} {
	#
	# Attribute is new for class
	#
	set new_domain($class.$attribute) $domain
	return
    }
    #
    # If domain is not changed, return
    #
    if {[cequal $domain $old_domain($class.$attribute)]} {
	return
    }
    #
    upvar #0 $attribute attribute_item
    set aname $attribute_item(unameit_attribute_name)
    #
    upvar #0 $class class_item
    set cname $class_item(unameit_class_name)
    #
    if {[catch {unameit_check_no_instances $cname -deleted $aname}]} {
	unameit_error EATTRDOMAINLOSEDATA $class $attribute
    }
    set new_domain($class.$attribute) $domain
}

#
# Find most specific domain for an attribute among a list of superclasses.
# ($attribute is defining metadata uuid)
#
proc unameit_compute_attribute_domain {class supers attribute level} {
    upvar #$level UNAMEIT_SUBS subs
    upvar #$level UNAMEIT_POINTER_DOMAIN computed_domain
    #
    foreach super $supers {
	set domains($computed_domain($super.$attribute)) 1
    }
    set candidates [array names domains]
    unset domains
    #
    foreach domain $candidates {
	set candidates [intersect $candidates [concat $domain $subs($domain)]]
	if {[cequal $candidates ""]} {
	    unameit_error EDOMAINCONFLICT $class $attribute $supers
	}
    }
    #
    # Must have one element when done,  since if two domains are each a
    # subclass of the other,  they are equal.
    #
    set candidates
}

proc unameit_check_attribute_domain {class attribute level} {
    upvar #0 UNAMEIT_POINTER_DOMAIN old_domain
    upvar #$level UNAMEIT_POINTER_DOMAIN computed_domain
    upvar #$level UNAMEIT_DIRECT_SUPERS direct_sups
    upvar #$level UNAMEIT_SUBS subs
    upvar #$level UNAMEIT_ISA isa
    #
    # Get the class and defining class of this attribute. We'll need this
    # information to see if the class we are processing has metadata
    # information for this attribute.
    #
    upvar #$level $attribute attribute_item
    set defining [info exists attribute_item(unameit_attribute_name)]
    if {$defining} {
	set defining_attribute $attribute
    } else {
	set defining_attribute $attribute_item(unameit_attribute_whence)
    }
    upvar #$level $defining_attribute defining_attribute_item
    set attribute_class $attribute_item(unameit_attribute_class)
    set defining_class $defining_attribute_item(unameit_attribute_class)
    set domain $attribute_item(unameit_pointer_attribute_domain)
    #
    # Does this class define the attribute
    #
    if {[cequal $class $defining_class]} {
	#
	# The attribute is defined by the class.  Just read off the domain
	# and compare with the old if any.
	#
	unameit_check_domain_change $class $attribute $domain $level
	return
    }
    #
    # Get list of direct superclasses that share the attribute
    #
    set supers [intersect $direct_sups($class)\
		    [concat $defining_class $subs($defining_class)]]
    #
    if {[cequal $class $attribute_class] && ![cequal $domain ""]} {
	#
	# We have metadata for this attribute
	# And it provides a non-null domain this will be the new
	# domain,  but we need to compare it for compatibility with
	# every direct superclass that is a subclass of the defining class.
	# of the attribute.
	#
	foreach super $supers {
	    set super_domain $computed_domain($super.$defining_attribute)
	    if {![info exists isa($super_domain.$domain)]} {
		unameit_error EDOMAINCONFLICT $class $attribute $super
	    }
	}
	unameit_check_domain_change $class $defining_attribute $domain $level
	return
    }
    #
    # Attribute is inherited with no metadata or with no domain
    # in the metadata.
    #
    if {[llength $supers] == 1} {
	#
	# Optimization for typical single inheritance case!
	# Assume [list $uuid] is same as "$uuid"
	#
	set domain $computed_domain($supers.$defining_attribute)
    } else {
	set domain\
	    [unameit_compute_attribute_domain $class $supers\
		$defining_attribute $level]
    }
    unameit_check_domain_change $class $defining_attribute $domain $level
}

proc unameit_check_pointer_domains {level} {
    upvar #$level UNAMEIT_SUPS sups
    upvar #$level UNAMEIT_SUBS subs
    upvar #$level UNAMEIT_CLASS_UUID cuuid
    upvar #$level UNAMEIT_ATTRIBUTES attributes
    #
    # Compute a class hierarchy of just the data classes
    #
    set i_class $cuuid(unameit_item)
    set di_class $cuuid(unameit_data_item)
    set dsups($i_class) {}
    set dsubs($i_class) [concat $di_class $subs($di_class)]
    foreach class $dsubs($i_class) {
	set dsups($class) $sups($class)
	set dsubs($class) $subs($class)
    }
    #
    foreach class [unameit_sort_top_down dsups dsubs] {
	foreach attribute $attributes($class) {
	    upvar #$level $attribute attribute_item

	    if {[info exists\
		    attribute_item(unameit_pointer_attribute_domain)]} {
		unameit_check_attribute_domain $class $attribute $level
	    }
	}
    }
}

#
# Disallow referential integrity to change for populated pointers
#
proc unameit_check_pointer_integrity {level} {
    upvar #0 UNAMEIT_REF_INTEGRITY old_ref_int
    upvar #$level UNAMEIT_REF_INTEGRITY new_ref_int
    upvar #$level UNAMEIT_CLASS_UUID cuuid
    upvar #$level UNAMEIT_ATTRIBUTE_UUID auuid
    #
    foreach key [array names new_ref_int] {
	if {![info exists old_ref_int($key)]} continue
	if {[cequal $new_ref_int($key) $old_ref_int($key)]} continue
	lassign [split $key .] cname aname
	if {[catch {unameit_check_no_instances $cname -all $aname}]} {
	    unameit_error EATTRHASINSTANCES $cuuid($cname) $auuid($aname)
	}
    }
}

proc unameit_index_class {class} {
    upvar #0 UNAMEIT_CLASS_UUID cuuid
    upvar #0 UNAMEIT_ATTRIBUTES attributes
    upvar #0 UNAMEIT_MULTIPLICITY amul
    upvar #0 UNAMEIT_SYNTAX attribute_syntax
    #
    upvar #0 $class class_item
    #
    set refintAttr unameit_pointer_attribute_ref_integrity
    set cname $class_item(unameit_class_name)
    #
    # Fix each attribute in turn
    #
    foreach attribute $attributes($class) {
	#
	# Get attribute name and defining record
	#
	upvar #0 $attribute attribute_item
	set attribute_class $attribute_item(unameit_attribute_class)
	set defining [info exists attribute_item(unameit_attribute_name)]
	if {$defining} {
	    set defining_attribute $attribute
	} else {
	    set defining_attribute\
		$attribute_item(unameit_attribute_whence)
	}
	upvar #0 $defining_attribute defining_attribute_item
	set aname $defining_attribute_item(unameit_attribute_name)
	set defining_class $defining_attribute_item(unameit_attribute_class)
	#
	if {[cequal $defining_class $cuuid(unameit_item)]} continue
	#
	if {[cequal $class $defining_class] &&
		[info exists attribute_item($refintAttr)]} {
	    set syntax_class $attribute_item(Class)
	    upvar #0 $cuuid($syntax_class) syntax_class_item
	    if {[cequal $syntax_class_item(unameit_class_readonly) No] &&
		    ![cequal $amul($aname) Scalar]} {
		umeta_add_index "relation/$aname" lhs
	    }
	}
	#
	if {![cequal $class_item(unameit_class_readonly) No]} continue
	if {![cequal $amul($aname) Scalar]} continue
	switch -- $attribute_syntax($cname.$aname) {
	    address -
	    autoint -
	    choice -
	    enum -
	    integer -
	    pointer -
	    string -
	    time {
		umeta_add_index $cname $aname
	    }
	}
    }
}

#
# This function is called after a successful data restore,
# and build indices on all suitable data attributes,  and in particular
# on role name and owner ('role' is the only preloaded non-readonly data class)
# Called again it will be a NOOP.
#
proc unameit_build_indices {} {
    upvar #0 UNAMEIT_SUBS subs
    upvar #0 UNAMEIT_CLASS_UUID cuuid
    #
    if {[umeta_has_index role]} return
    #
    # Index data attributes and associated relation classes
    #
    unameit_index_class $cuuid(unameit_data_item)
    foreach class $subs($cuuid(unameit_data_item)) {
	unameit_index_class $class
    }
}
