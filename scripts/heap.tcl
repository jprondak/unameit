#
# Copyright (c) 1997 Enterprise Systems Management Corp.
#
# This file is part of UName*It.
#
# UName*It is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later
# version.
#
# UName*It is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with UName*It; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
# $Id: heap.tcl,v 1.13.10.3 1997/09/27 00:33:50 simpson Exp $
#

#
# Write to a heap file and index it with ndbm.
#

proc heap_open {prefix} {

    global env  HeapIndex HeapHeap
    
    package require Ndbmtcl

    set HeapIndex($prefix) [ndbm open $prefix]
    set heapfile $prefix.heap
    set HeapHeap($prefix) [open $heapfile a+ 0666]
    return 1
}

proc heap_close {prefix} {

    global  HeapIndex HeapHeap env 

    $HeapIndex($prefix) close
    unset HeapIndex($prefix)
    close $HeapHeap($prefix)
    unset HeapHeap($prefix)
    return 1
}

#
# To avoid limits on data in ndbm, the data are written to the heap.
# Keys are still limited. Since lgets is used to read
# records, the length is not recorded.
#
proc heap_write {prefix data key} {

    global  HeapIndex HeapHeap

    seek $HeapHeap($prefix) 0 end
    set offset [tell $HeapHeap($prefix)]
    puts $HeapHeap($prefix) $data
    $HeapIndex($prefix) insert $key $offset 

    return 1
}

proc heap_fetch {prefix p_data key} {

    upvar 1 $p_data data
    global  HeapIndex HeapHeap 
    log_debug "get data for '$key' in $prefix"

    if {! [$HeapIndex($prefix) fetch $key offset]} {
	log_debug "not found"
	return 0
    }
    log_debug "offset $offset"
    
    seek $HeapHeap($prefix) $offset
    lgets $HeapHeap($prefix) data
}

###########################################################################
#
# Oid Heap - a collection of data keyed by OID, based on the above heap.

#
# OidHeap($heap_dir) is set to the prefix used by the heap commands.
# OidIndexes($heap_dir) is set the the ndbm handle of the indexes.
#
# Index data are of many types. One is Oid by various keys which
# include the Class. These are objects whose keys start with OidOf
#
# Other data items are not really indexes,
# but are actual data (e.g. ClassCount) TBD - put into a different
# file?
#	ClassCount(Class)		number of instances
#	Ipv4Owner(ipv4_address) 	oid of the owner of an IP address
#	InterfaceCount(Oid of host)	number of interfaces a host has
#
# Also stored are some commonly used data fields that are short enough
# and needed often enough. Some objects do not have these fields 
# (except for the mandatory Class field).
#
#	ClassOf(Oid)		
#	
# Also stored are Oids of things which are treated as fake classes,
# whose names are capitalized to ensure that they do not get
# output to the final dat files. (NOTE: unameit field names always
# are lower case names. Only settable attributes are written to dat files.)
#
#	HostName(name,domain)		other names for a host
#	Person(name,domain)		all subclasses of person
#
# The global variable OidSuperclass(x) can be set to indicate that
# a fake index is to be used. For example, if the subclasses of
# person include employee and consultant, OidSuperclass(consultant)
# will be set to Person.

# ClassCount is used to generate oids.

# HostNames include real hosts, host aliases, and aliases that 
# would be generated by uname-it for the interfaces.

# Ipv4Owner is used to find IP address owners.

# InterfaceCount is used to generate artificial interface names
# if required.

# In the original Info.tcl file is oid2classname, which is used 
# by role classes. This information is saved as Oid2Classname(Oid)
# with oids that are used by objects but are not keys in the data files.

# NOTE: the lists of classes will get too large for dbm, and the
# heap is a poor choice for continually updated objects. We 
# construct these lists, then update them whenever creating
# objects. For now, we assume that the list in question is not changing.
# For example, the set of domains in the organization will not change
# when adding hosts. See get_domain_oids, which processes the heap
# index and puts the results into globals.
# If this becomes a performance issue, another option is to keep oids 
# of these classes in individual files. 

###########################################################################
#
# Open a directory, copy all existing files to a heap.
# Data are lists (e.g. name harry owner x.y.com) indexed by OID.
# TBD use direct code instead of dump_process_class.
#
# Load classes in the correct order for the indexing to work.
# For example, the owner of a host_alias is the actual host,
# which we wish to use for indexing. 
#
# The data directory and the heap directory can
# be different; putting the heap in /tmp may be a lot faster.
# 
proc oid_heap_input_dat {data_dir heap_dir} {
    
    # globals are set by dump_open_dir
    global unrestored oid2classname

    dump_open_dir $data_dir r
    oid_heap_open $heap_dir

    set must_do [concat \
	    organization \
	    cell \
	    region \
	    [unameit_get_subclasses host]]

    set also_do [lindex [intersect3 [array names unrestored] $must_do] 0]

    foreach class [concat $must_do $also_do] {
	dump_process_class $class {
	    set F(Oid) $oid
	    oid_heap_create_a $heap_dir F
	}
    }
    
    set f [open [file join $heap_dir Oid2Classname] w]
    puts $f [array get oid2classname]
    close $f

    oid_heap_close $heap_dir
    dump_close_dir
}

proc oid_heap_get_classnames {heap_dir p_names} {
    upvar 1 $p_names names

    set f [open [file join $heap_dir Oid2Classname] r]
    lgets $f names
    close $f
}

###########################################################################
#
# Write out .dat files. Files which must be sorted are:
#
# network sorted by ascending first address and descending last address.
#
# cells and regions must be dot-sorted, so the owners will be found.
# We use dot-sort to process new regions in the correct order.
#


proc oid_heap_output_dat {data_dir heap_dir} {
    global HeapIndex OidHeap
    # Make an empty Info file
    set f [open [file join $data_dir Info.tcl] w]
    close $f

    dump_open_dir $data_dir

    if {! [oid_heap_open $heap_dir]} {
	puts "oid_heap_open failed"
	return
    }

    set dbmcmd $HeapIndex($OidHeap($heap_dir))
    for {set more [$dbmcmd first oid]} {$more} {set more [$dbmcmd next oid]} {
	oid_data_get $heap_dir class [list ClassOf $oid]
	lappend classoids($class) $oid
	set class ""
    }

    # Get the name field for regions and cells
    foreach class [list cell region] {
	catch {unset oids_by_name}

	if {[info exists classoids($class)]} {
	    foreach oid $classoids($class) {
		oid_heap_get_data_a $heap_dir item $oid
		set name $item(name)
		set oids_by_name($name) $oid
	    }

	    dump_edit_class $class

	    foreach name [lsort -command dots [array names oids_by_name]] {
		set oid $oids_by_name($name)
		if {! [oid_heap_get_data_a $heap_dir item $oid]} {
		    error "lost data for $oid"
		}
		dump_put_instance_a item
	    }
	    
	    dump_close_class $class
	}
    }

    # Make netkeys for each network, then output in sorted order
    if {[info exists classoids(ipv4_network)]} {
	foreach oid $classoids(ipv4_network) {
	    if {! [oid_heap_get_data_a $heap_dir item $oid]} {
		error "lost data for $oid"
	    }
	    set netkey [make_netkey item]
	    set netoids($netkey) $oid
	}
    
	dump_edit_class ipv4_network
    
	foreach netkey [lsort [array names netoids]] {
	    set oid $netoids($netkey)
	    if {! [oid_heap_get_data_a $heap_dir item $oid]} {
		error "lost data for $oid"
	    }
	    dump_put_instance_a item
	}

	dump_close_class ipv4_network
    }

    # Remove cell, network and region from the list of classes to dump
    # Order matters,  since we may have no regions!
    catch {unset classoids(cell) classoids(ipv4_network) classoids(region)}

    # Dump all classes
    foreach class [array names classoids] {

	dump_edit_class $class

	foreach oid $classoids($class) {
	    if {! [oid_heap_get_data_a $heap_dir item $oid]} {
		error "lost data for $oid"
	    }
	    dump_put_instance_a item
	}

	dump_close_class $class
    }

    dump_close_dir
    return
}

###########################################################################

proc oid_heap_open {heap_dir} {
    global OidHeap OidIndexes OidSuperclass

    set OidHeap($heap_dir) [file join $heap_dir OidData]
    heap_open $OidHeap($heap_dir)

    set OidIndexes($heap_dir) [ndbm open [file join $heap_dir OidIndexes]]

    foreach class [concat person [unameit_get_subclasses person]] {
	set OidSuperclass($class) Person
    }
    foreach class [concat host [unameit_get_subclasses host]] {
	set OidSuperclass($class) Host
    }

    return 1
}

proc oid_heap_close {heap_dir} {
    global OidHeap OidIndexes

    heap_close $OidHeap($heap_dir) 
    $OidIndexes($heap_dir) close

    unset OidHeap($heap_dir) OidIndexes($heap_dir)
    return 1
}

#
# Get the data as a list
#
proc oid_heap_get_data_l {heap_dir p_data key}  {
    upvar 1 $p_data data
    global OidHeap

    heap_fetch $OidHeap($heap_dir) data $key 
}

#
# Put the data directly into an array.
#
proc oid_heap_get_data_a {heap_dir p_data key}  {
    upvar 1 $p_data data
    global OidHeap

    if {[heap_fetch $OidHeap($heap_dir) tmp $key]} {
	catch {unset data}
	array set data $tmp
	return 1
    }
    return 0
}

#
# Internal routines, the keylist is in key.
#
proc oid_data_incr {heap_dir key} {
    global OidIndexes 

    set ndbm $OidIndexes($heap_dir)

    if {! [$ndbm fetch $key count]} {
	set count 0
    }
    $ndbm insert $key [incr count]
    return $count
}

proc oid_data_get {heap_dir v key} {
    upvar $v data
    global OidIndexes 

    log_debug "oid_data_get '$key'"

    set ndbm $OidIndexes($heap_dir)
    $ndbm fetch $key data
}

proc oid_data_set {heap_dir data key} {
    global OidIndexes 

    log_debug "oid_data_set data '$key'"

    set ndbm $OidIndexes($heap_dir)
    $ndbm insert $key $data
}


#
# A one at a time object creation routine.
# The object will be written to the heap and the indexes updated.
# If the Oid field is "" or not set, an Oid will be generated.
# If the ifname of an ipv4_interface is "" or unset, a name will be generated.
#
# The OID will be returned. This can be used to get the name, if desired.
#
# We filter out non-settable attributes.
#
# Fake classes are used for superclasses. These are:
#	
#	HostName	subclasses of host, host_alias
#	Automount	automount, user_login
#	Person		subclasses of person

proc oid_heap_create_a {heap_dir v} {
    upvar 1 $v F
    global OidHeap OidIndexes OidSuperclass

    #
    # Increment the instance count for this class
    #
    set count [oid_data_incr $heap_dir [list ClassCount $F(Class)]]

    #
    # Generate an oid if needed. Set uuid to "" if needed.
    #
    if {! [info exists F(Oid)] || [cequal "" $F(Oid)]} {
	set F(Oid) [list $F(Class) $count]
    }
    if {! [info exists F(uuid)]} {
	set F(uuid) ""
    }

    set this_class $F(Class)
    if {[info exists OidSuperclass($F(Class))]} {
	set this_class $OidSuperclass($F(Class))
    }
    switch -exact -- $this_class {
	organization -
	cell -
	region {
	    oid_data_set $heap_dir $F(Oid) [list OidOf $F(Class) $F(name)]
	}
	
	Person {
	    set fullname $F(fullname)
	    if {[regexp {^([^,]*), *(.*)$} $fullname x last_name rest]} {
		regsub -all , $rest {} rest
		set fullname "$rest $last_name"
	    }
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf Person $fullname $F(owner)]
	    if {[info exists F(name)] && ![cequal $F(name) ""]} {
		oid_data_set $heap_dir $F(Oid)\
		    [list OidOf MailBox $F(name) $F(owner)]
	    }
	}
	
	automount_map -
	mailing_list -
	netgroup {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(name) $F(owner)]
	}
 
	system_login -
	application_login {
	    # Logins are indexed by name and uid, in the domain
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(name) $F(owner)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) uid $F(uid) $F(owner)]
	}
	
	user_login {
	    # user_logins are also Automounts
	    # Automounts are indexed by name within the map
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(name) $F(owner)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) uid $F(uid) $F(owner)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf UserAutomount $F(name) $F(auto_map)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf MailBox $F(name) $F(owner)]
	}

	system_group -
	application_group -
	user_group {
	    # groups are indexed by name and gid, in the domain
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(name) $F(owner)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) gid $F(gid) $F(owner)]
	}

	Host {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(name) $F(owner)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf HostName $F(name) $F(owner)]
	    if {! [cequal ""  $F(ifname)]} {
		oid_data_set $heap_dir $F(Oid)\
		    [list OidOf HostName "$F(name)-$F(ifname)" $F(owner)]
	    }
	    if {! [cequal ""  $F(ipv4_address)]} {
		oid_data_set $heap_dir $F(Oid)\
		    [list Ipv4Owner $F(ipv4_address)]
	    }
	}	    

	ipv4_secondary_address {
	    # The owner is the actual user of the address.
	    oid_data_set $heap_dir $F(owner) [list Ipv4Owner $F(ipv4_address)]
	}

	ipv4_interface {   
	    # get the owner, whose domain is needed for indexing
	    catch {unset owner}
	    oid_heap_get_data_a $heap_dir owner $F(owner)
	    
	    # increment number of interfaces 
	    # generate a name if there is none
	    set ifcount \
		    [oid_data_incr $heap_dir [list InterfaceCount $F(owner)]]
	    if {! [info exists F(ifname)] || [cequal "" $F(ifname)]} {
		set F(ifname) if$ifcount
	    }
	    
	    # save the host-interface name as a HostName
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf HostName "$owner(name)-$F(ifname)" $owner(owner)]
	    
	    # The owner is the actual user of the address.
	    oid_data_set $heap_dir $F(owner) [list Ipv4Owner $F(ipv4_address)]
	}

	host_alias {
	    # get the owner, whose domain is needed for indexing
	    # the domain will be the owner field of the host
	    catch {unset owner}
	    oid_heap_get_data_a $heap_dir owner $F(owner) 
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf HostName $F(name) $owner(owner)]
	}	

	server_alias {
	    # This alias is a HostName in the domain. 
	    # We index by name and owner to prevent duplicates.
	    # The owner is the domain.
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(server_type) $F(owner)]
	}

	ipv4_network {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(ipv4_net_start)]
	}

	group_member {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) $F(owner) $F(gm_login)]
	}

	mailing_list_member {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf Ememb $F(owner) $F(ml_member)]
	}

	server_type {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) type $F(server_type_name)]	    
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf $F(Class) name $F(name)]	
	}

	automount {
	    # Automounts are indexed by name map and domain
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf Automount $F(name) $F(auto_map) $F(owner)]
	}

	external_mail_address {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf Eaddr $F(name) $F(owner)]
	}
	tcp_service {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf name/tcp $F(ip_service_name)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf port/tcp $F(tcp_port)]
	}
	udp_service {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf name/udp $F(ip_service_name)]
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf port/udp $F(udp_port)]
	}
	tcp_service_alias {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf name/tcp $F(ip_service_name)]
	}
	udp_service_alias {
	    oid_data_set $heap_dir $F(Oid)\
		[list OidOf name/udp $F(ip_service_name)]
	}
    }
    
    # Save the class and instance number in ndbm
    oid_data_set $heap_dir $F(Class) [list ClassOf $F(Oid)]
    
    # Save the data in the heap. Remove unsettable fields.
    foreach field [concat Oid Class uuid \
	    [unameit_get_settable_attributes $F(Class)]] {
	if {[info exists F($field)]} {
	    set item($field) $F($field)
	}
    }
    heap_write $OidHeap($heap_dir) [array get item] $item(Oid) 

    # Log and return the oid
    log_create "$item(Oid): [array get item]"
    return $item(Oid)
}

#
# A convenience routine; copies arguments into an array and
# invokes the creation routine.
#
proc oid_heap_create_l {heap_dir args} {
    array set F $args
    oid_heap_create_a $heap_dir F
}


###########################################################################
#
# Get OID routines. These depend on oid_heap_create doing the indexing.
#

proc oid_get_class {heap_dir p_class oid} {
    upvar 1 $p_class class
    oid_data_get $heap_dir class [list ClassOf $oid]
}

proc get_domain_oid {heap_dir p_oid domain} {
    upvar 1 $p_oid domain_oid
    expr {
	[oid_data_get $heap_dir domain_oid [list OidOf region $domain]] ||
	[oid_data_get $heap_dir domain_oid [list OidOf cell $domain]]
    }
}

#
# Group members are indexed by group (oid) and login (oid)
#
proc get_group_member_oid {heap_dir p_oid group_oid gm_login} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf group_member $group_oid $gm_login]
}

proc get_automount_map_oid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf automount_map $name $domain]
}

proc get_person_oid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf Person $name $domain]
}

proc get_mailing_list_oid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf mailing_list $name $domain]
}

proc get_netgroup_oid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf netgroup $name $domain]
}

proc get_user_login_oid_by_name {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf user_login $name $domain]
}

proc get_application_login_oid_by_name {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf application_login $name $domain]
}

proc get_system_login_oid_by_name {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf system_login $name $domain]
}

proc get_user_login_oid_by_uid {heap_dir p_oid uid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf user_login uid $uid $domain]
}

proc get_application_login_oid_by_uid {heap_dir p_oid uid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf application_login uid $uid $domain]
}

proc get_system_login_oid_by_uid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf system_login uid $name $domain]
}

proc get_user_group_oid_by_name {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf user_group $name $domain]
}

proc get_application_group_oid_by_name {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf application_group $name $domain]
}

proc get_user_group_oid_by_gid {heap_dir p_oid gid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf user_group gid $gid $domain]
}

proc get_application_group_oid_by_gid {heap_dir p_oid gid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf application_group gid $gid $domain]
}

proc get_organization_oid {heap_dir p_oid name} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf organization $name]
}

proc get_cell_oid {heap_dir p_oid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf cell $domain]
}

proc get_region_oid {heap_dir p_oid domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf region $domain]
}

proc get_network_oid {heap_dir p_oid ipv4_net_start} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf ipv4_network $ipv4_net_start]
}

#
# Get the oid for the unameit server type (e.g. mailhost, not my_mail_server)
#
proc get_server_type_oid_by_type {heap_dir p_oid server_type_name} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf server_type type $server_type_name]
}

#
# Get the oid for the users server type (e.g.my_mail_server)
#
proc get_server_type_oid_by_name {heap_dir p_oid name} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf server_type name $name]
}

proc get_ipv4_owner_oid {heap_dir p_oid ipv4_address} {
    upvar 1 $p_oid oid
    set r [oid_data_get $heap_dir oid [list Ipv4Owner $ipv4_address]]
    log_debug "get_ipv4_owner_oid $ipv4_address = '$r'"
    return $r
}

#
# get a server alias indexed by oid-of-type and oid-of-domain
#
proc get_server_alias_oid {heap_dir p_oid server_type domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf server_alias $server_type $domain]
}

#
# Get external_mail_address by string and domain.
#
proc get_address_oid {heap_dir p_oid addr domain} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf Eaddr $addr $domain]
}

#
# Get mailing_list_member by list and destination.
#
proc get_mailing_list_member_oid {heap_dir p_oid list dest} {
    upvar 1 $p_oid oid
    oid_data_get $heap_dir oid [list OidOf Ememb $list $dest]
}

#
# Get the oid of a host by its name or alias
#
proc get_hostname_oid {heap_dir p_oid name domain} {
    upvar 1 $p_oid oid 
    oid_data_get $heap_dir oid [list OidOf HostName $name $domain] 
}

proc get_service_name {heap_dir p_oid proto name} {
    upvar 1 $p_oid oid 
    oid_data_get $heap_dir oid [list OidOf name/$proto $name] 
}

proc get_service_port {heap_dir p_oid proto port} {
    upvar 1 $p_oid oid 
    oid_data_get $heap_dir oid [list OidOf port/$proto $port] 
}

#
# The lookup routines search various places to find things.
# This routine looks up a hostname (host or host_alias) in the list 
# of oids (usually obtained by get_domain_oids). It also looks 
# in the . cell.
#
proc lookup_hostname_oid {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_hostname_oid $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    get_cell_oid $heap_dir cell_oid .
    if {[get_hostname_oid $heap_dir oid $name $cell_oid]} {
	return 1
    }
    return 0
}

#
# Look for a person in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_person_oid {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_person_oid $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for an automount user_login in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_automount {heap_dir p_oid name map owner} {
    upvar 1 $p_oid oid
    #
    if {[oid_data_get $heap_dir oid [list OidOf UserAutomount $name $map]]} {
	return 1
    }
    oid_data_get $heap_dir oid [list OidOf Automount $name $map $owner]
}

#
# Look for a user_login in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_mbox_oid {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 
    #
    foreach domain $oid_list {
	if {[oid_data_get $heap_dir oid [list OidOf MailBox $name $domain]]} {
	    return 1
	}
    }
    return 0
}

#
# Look for a user_login in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_user_login_oid_by_name {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 
    #
    foreach domain $oid_list {
	if {[get_user_login_oid_by_name $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for an application_login or system_login in this list of oids, 
#
proc lookup_appsys_login_oid_by_name {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_application_login_oid_by_name $heap_dir oid $name $domain] ||
		[get_system_login_oid_by_name $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for an application_login or system_login in this list of oids.
#
proc lookup_appsys_login_oid_by_uid {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_application_login_oid_by_uid $heap_dir oid $name $domain] ||
		[get_system_login_oid_by_uid $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}


#
# Look for a user_group in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_user_group_oid_by_name {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_user_group_oid_by_name $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for a application_group in this list of oids, which is that
# of OidsInOrg($OrgOid) or oids up the tree.
#
proc lookup_application_group_oid_by_name {heap_dir p_oid name p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_application_group_oid_by_name $heap_dir oid $name $domain]} {
	    return 1
	}
    }
    return 0
}


#
# Look for a user_login in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_user_login_oid_by_uid {heap_dir p_oid uid p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_user_login_oid_by_uid $heap_dir oid $uid $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for a user_group in this list of oids, which is usually that
# of OidsInOrg($OrgOid).
#
proc lookup_user_group_oid_by_gid {heap_dir p_oid gid p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_user_group_oid_by_gid $heap_dir oid $gid $domain]} {
	    return 1
	}
    }
    return 0
}

#
# Look for a application_group in this list of oids, which is that
# of OidsInOrg($OrgOid) or oids up the tree.
#
proc lookup_application_group_oid_by_gid {heap_dir p_oid gid p_oid_list} {
    upvar 1 $p_oid oid \
	    $p_oid_list oid_list 

    foreach domain $oid_list {
	if {[get_application_group_oid_by_gid $heap_dir oid $gid $domain]} {
	    return 1
	}
    }
    return 0
}


#
# To find a host by name, we look for:
#   if this is a server_alias, look for
#	server_alias in this domain, or a parent domain up to the cell
#   otherwise, look for
#	HostName in the org (includes all subclasses of host and host_alias)
#	HostName in .
#
# name may be unqualified. If so, use RegionOid as the starting point
# of the search.
#
# If in_cell is true, the search is narrowed to domains within the cell.
#
proc lookup_host_oid {heap_dir p_oid host {in_cell 0}} {
    upvar 1 $p_oid oid 
    global RegionOid OidsInOrg OidsUpTree CellOf CellOid OrgOid OrgOf

    #
    # If a qualified name is not found, use the default
    #
    if {[split_domain $host domain_name host_name]} {
	
	# unknown domain, discard
	if {! [get_domain_oid $heap_dir domain_oid $domain_name]} {
	    return 0
	}

	# limited to this cell?
	if {$in_cell} {
	    if {! [cequal $CellOf($domain_oid) $CellOid]} {
		return 0
	    }
	}

	# set the org in case we look for hosts
	set org_oid $OrgOf($domain_oid)
    } else {
	set host_name $host
	set domain_oid $RegionOid
	set org_oid $OrgOid
    }
    
    switch -- [lookup_server_alias $heap_dir oid $host_name $domain_oid] {
	0 {return 0}
	1 {return 1}
    }
    lookup_hostname_oid $heap_dir oid $host_name OidsInOrg($org_oid)
}

#
proc lookup_canon_host {heap_dir p_oid p_host_oid host domain_oid} {
    upvar 1 $p_oid oid $p_host_oid host_oid
    global OidsInOrg OrgOid OrgOf

    switch -- [lookup_server_alias $heap_dir oid $host $domain_oid] {
	0 {return 0}
	1 {
	    oid_heap_get_data_a $heap_dir F $oid
	    set host_oid $F(primary_server)
	    return 1
	}
    }
    if {[lookup_hostname_oid $heap_dir oid $host\
	    OidsInOrg($OrgOf($domain_oid))]} {
	set host_oid $oid
	return 1
    }
    return 0
}

proc lookup_server_alias {heap_dir oidVar name domain_oid} {
    global OidsUpTree ServerNames
    upvar 1 $oidVar oid
    #
    if {![info exists ServerNames($name)]} {return -1}
    #
    foreach d $OidsUpTree($domain_oid) {
	if {[get_server_alias_oid $heap_dir oid $ServerNames($name) $d]} {
	    return 1
	}
    }
    return 0
}

#
# Given a string 'user' or 'user@location', split it up and look up
# the location. If there is no location use the default RegionOid.
# If the location is unknown, return false.
# Set uname to the user (string).
# If the location is found, set doname to the domain (oid).
# If there is a host part to the name, set honame to the name of the host.
# Set lname to the location (string)
#  
proc lookup_location {heap_dir name svar lvar hvar dvar} {
    upvar 1 $svar short_name \
	    $lvar location \
	    $hvar host_name \
	    $dvar domain_oid
    global RegionOid

    set short_name $name
    set host_name ""
    set domain_oid ""

    if {[regexp {^([^@]+)@([^@]+)$} $name x short_name location] == 0} {
	#
	# unqualified name must be in this region
	#
	set domain_oid $RegionOid
	return 1
    } 

    #
    # If there is a host and/or domain, look it up.
    #
    if {[get_domain_oid $heap_dir domain_oid $location]} {
	return 1
    }
    
    #
    # Check to see if this was a host.location
    # return the result
    #
    if {[split_domain $location location host_name]} {
	return [get_domain_oid $heap_dir domain_oid $location]
    }

    #
    # Just host qualified name,  is in this region
    #
    set domain_oid $RegionOid
    return 1
}

#
# We look for user logins in the organization of the location, 
# then look for system and application logins somewhere up the
# tree, stopping at the cell. 
#
proc lookup_login {heap_dir v name domain_oid} {
    upvar 1 $v login_oid
    global OidsInOrg OidsUpTree OrgOf 

    set org_oid $OrgOf($domain_oid)

    expr {
	[lookup_user_login_oid_by_name $heap_dir login_oid\
	    $name OidsInOrg($org_oid)] ||
	[lookup_appsys_login_oid_by_name $heap_dir login_oid\
	    $name OidsUpTree($domain_oid)]
    }
}

#
# Look up a login given a string 'user' or 'user@location'.
# We look for user logins in the organization of the location, 
# then look for system and application logins somewhere up the
# tree, stopping at the cell. Location may be empty, in which
# case we use the default RegionOid, OrgOid. Location may be
# host.domain or domain. Return false unless we find the domain
# and the login.
#
proc lookup_login_address {heap_dir v name} {
    upvar 1 $v login_oid
    global RegionOid OrgOid OidsInOrg OidsUpTree OrgOf 

    if {! [lookup_location $heap_dir $name login l h domain_oid]} {
	return 0
    }
    lookup_login $heap_dir login_oid $login $domain_oid
}


#
# Look up a server alias of type mailhost for this domain, looking
# up the tree within the cell. Return the oid, or "" if none is found.
#
proc get_mailhost {heap_dir domain_oid type} {
    global OidsUpTree

    if {[get_server_type_oid_by_type $heap_dir st_oid $type]} {
	foreach d $OidsUpTree($domain_oid) {
	    if {[get_server_alias_oid $heap_dir oid $st_oid $d]} {
		oid_heap_get_data_a $heap_dir F $oid
		return $F(primary_server)
	    }
	}
    } else {
	log_warn "No $type server type in database!"
    }
    return ""
}

#
# Look up the oid of the network, get the object, and return
# the netmask field. Return 0 if not found.
#
proc get_netmask {heap_dir p_mask ipv4_net_start} {
    upvar 1 $p_mask mask
    if {! [get_network_oid $heap_dir net_oid $ipv4_net_start]} {
	return 0
    }
    if {! [oid_heap_get_data_a $heap_dir net_data $net_oid]} {
	error "bug: lost data for $net_oid, network $ipv4_net_start"
    }
    switch -- $net_data(ipv4_net_type) {
	Fixed {
	    set mask $net_data(ipv4_net_mask)
	}
	default {
	    set mask ""
	}
    }
    return 1
}

#
# Look up the domain, its containing cell, and the org for the cell.
# It is assumed that domains are never added after this routine is called.
# If there is no org for the cell (e.g. cellorg is "") then the cell
# is used as an org oid. Returns 0 if the domain is not in the database.
# Tree ascension is done lexically; when looking at x.y.z.com, if it is
# not a cell then y.z.com will be checked.
#
# Variables are set to store the name and oid of various classes.
# e.g. RegionNames($oid) = name
# This allows the caller to get a list of all of the regions.
# Same for cells and orgs.
#
# OidsInCell and OidsInOrg are indexed by oid, and consist of a list of
# oids contained in the cell or organization.
#
# OidsUpTree($oid) is a list of domain oids ascending the tree up to
# the cell level.
#
# This routine raises error if the domain is not found or there is corrupt
# data somehow.
#
# TBD - cache the DotCellOid? 
#
# TBD - keep a list of hosts in each cell?
#
proc get_domain_oids {heap_dir domain} {
    global HeapIndex OidHeap
    global \
	    CellOf OrgOf \
	    OidsInCell OidsInOrg \
	    DomainNames CellNames RegionNames Orgnames \
	    OidsUpTree ServerNames \
	    RegionOid OrgOid CellOid

    if {! [get_domain_oid $heap_dir RegionOid $domain]} {
	error "region or cell $domain was not found"
    }

    catch {unset ServerNames}
    #
    # Process each oid in the database, ignoring all but a few
    # classes. 
    #
    set dbmcmd $HeapIndex($OidHeap($heap_dir))
    for {set more [$dbmcmd first oid]} {$more} {set more [$dbmcmd next oid]} {

	if {! [oid_get_class $heap_dir class $oid]} {
	    error "lost class of $oid"
	}

	switch -exact -- $class {
	
	    server_type {
		oid_heap_get_data_a $heap_dir st_data $oid
		set name $st_data(name)
		set ServerNames($name) $oid 
	    }

	    organization {
		oid_heap_get_data_a $heap_dir org_data $oid

		# save name by oid
		set OrgNames($oid) $org_data(name)

		# initialize list
		set OidsInOrg($oid) [list]
	    }

	    cell {
		set CellOf($oid) $oid

		# Get the org for the cell.
		oid_heap_get_data_a $heap_dir cell_data $oid

		if {[cequal "" $cell_data(cellorg)]} {
		    set org $oid
		} else {
		    set org $cell_data(cellorg)
		}
		set OrgOf($oid) $org

		# save cell name by oid
		set CellNames($oid) $cell_data(name)

		# initialize list; cell contains itself as a region
		set OidsInCell($oid) [list $oid]
		set OidsUpTree($oid) [list $oid]
	    }
	    
	    region {
		oid_heap_get_data_a $heap_dir region_data $oid
		set RegionNames($oid) [set domain $region_data(name)]

		set OidsUpTree($oid) [list $oid]

		while 1 {
		    split_domain $domain domain here

		    if {[cequal $domain $here]} {
			error "no cell contains $region"
		    }
		    
		    if {[get_region_oid $heap_dir region $domain]} {
			lappend OidsUpTree($oid) $region
		    }

		    if {[get_cell_oid $heap_dir cell $domain]} {
			set CellOf($oid) $cell
			lappend OidsUpTree($oid) $cell
			break
		    }
		}
	    }
	}
    }

    #
    # Put all cells onto the list of oids in orgs.
    #
    foreach {cell name} [array get CellNames] { 
	set org $OrgOf($cell)
	lappend OidsInOrg($org) $cell
	set DomainNames($cell) $name
    }

    #
    # Propagate OrgOf down to the regions, and add the regions to
    # the lists for cell and org.
    #
    foreach {region name} [array get RegionNames] { 
	set cell $CellOf($region)
	set org $OrgOf($cell)
	set OrgOf($region) $org
	lappend OidsInOrg($org) $region
	lappend OidsInCell($cell) $region
	set DomainNames($region) $name
    }

    #
    # Set the defaults for this particular domain.
    #
    set CellOid $CellOf($RegionOid)
    set OrgOid $OrgOf($RegionOid)
}
